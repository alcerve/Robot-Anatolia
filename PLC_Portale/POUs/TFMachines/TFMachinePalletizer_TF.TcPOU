<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="TFMachinePalletizer_TF" Id="{ce1a6238-33a3-4cee-9168-3b2637989b68}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TFMachinePalletizer_TF
VAR_INPUT
	Cmd 		: CommandBuffer;
	Cfg 		: Config;
	IN  		: TFMachinePalletizer_IN;
	
	Modules 					: POINTER TO TFPalletizerModules;
	
	WorkSpace 					: POINTER TO TFMachinePalletizer_WorkSpace;
	WorkFootprint 				: POINTER TO ARRAY [1..MAXFOOTPRINT] OF TFMachinePalletizer_WorkFootprint;
	WorkPickPoint 				: POINTER TO ARRAY [1..MAXPICKPOINT] OF TFMachinePalletizer_WorkPickPointSlab;
	WorkPickPointState 			: POINTER TO ARRAY [1..MAXPICKPOINT] OF TFMachinePalletizer_WorkPickPoint_State;
	//WorkPickPointTransportState	: POINTER TO ARRAY [1..MAXPICKPOINT] OF TFMachinePalletizer_WorkPickPointTransport_State;
	//WorkPickPointStoreState		: POINTER TO ARRAY [1..MAXPICKPOINT] OF TFMachinePalletizer_WorkPickPointStore_State;
	WorkPickPointDimension 		: POINTER TO ARRAY [1..MAXPICKPOINT] OF Work_PickPoint_Dimension;
	WorkPickPointOffset 		: POINTER TO ARRAY [1..MAXPICKPOINT] OF TFMachinePalletizer_WorkPickPointOffset;
	
	WorkArea 					: POINTER TO ARRAY [1..MAXAREA] OF TFMachinePalletizer_WorkArea;
	WorkAreaState 				: POINTER TO ARRAY [1..MAXAREA] OF TFMachinePalletizer_WorkAreaState;
	WorkAreaOffset 				: POINTER TO ARRAY [1..MAXAREA] OF TFMachinePalletizer_WorkAreaOffset;
	WAPointer 					: ARRAY [1..MAXAREA] OF TFMachinePalletizer_WorkAreaSort;			
	AxisOverride 				: POINTER TO TFMachinePalletizer_VelocityOverride_TF;			//Indica la struttura degli Override
	Pallet 						: POINTER TO ARRAY [1..MAXPALLET] OF TFMachinePalletizer_Pallet;		//Indica la struttura dei Pallet
	Layer 						: POINTER TO ARRAY [1..MAXLAYER] OF TFMachinePalletizer_Layer;		//Indica la struttura delle falde
	Forming 					: POINTER TO ARRAY [1..MAXFORMING] OF TFMachinePalletizer_FormingForSlab; //Indica la Struttura delle formature
	//AxisParK 					: POINTER TO Ax_Palletizer_Parameters;	//Parametri asse K
	
	ManCmd 						: POINTER TO TFModulePalletizerRobot_ManCmd;
	Mission 					: POINTER TO TFMachinePalletizer_Mission;	//Indica la missione in esecuzione
	Traiettoria 				: POINTER TO TFTraiettoria;				//Indica i parametri della traiettoria
	
	PickPlaceParameters			: POINTER TO TFMachinePalletizer_PickPlaceParameters;// Parametri Presa&Rilascio Piastrella/Falda/Pallet
	MachineManCmd 				: POINTER TO TFMachinePalletizer_ManCmd;
	ProgressiveNrWA 			: POINTER TO UDINT;
	UsedCode 					: POINTER TO ARRAY [1..MAXFORMINGCODE] OF INT;
	TCPParameter 				: POINTER TO TFModulePalletizerRobot_TCPPar;				// Indica i parametri delle manine(solitamente è valorizzata l'altezza "Z")
	TilterPack 					: POINTER TO ARRAY [1..MAXHANDLINGSTACK] OF TFHandlingPack;	// Indica il pacco presente sul ribaltino
	//UniqueCycle : BOOL;
	PreviousPWA 				: POINTER TO INT;
	RestoreCWA 					: POINTER TO BOOL;
	//TouchErrorEnable : BOOL;
	GateAccesExecuted 			: BOOL;
	PreviousStackWA 			: POINTER TO INT;
	WorkAreaZone 				: POINTER TO TFMachinePalletizer_WorkAreaZone; // Indica la suddivisione a zone delle WorkArea
	//HandlingPackTable : POINTER TO TFHandlingPackTable; 		// Tabella dei pacchi presenti sui trasporti
	ArrayPacchi 				: POINTER TO DUT_ArrayPacchi; 					//Array contenente i pacchi sui trasporti				

	PX_GripPresence 			: BOOL; //Fotocellula presenza Materiale su pinza
	
	WorkAreaManager 			: POINTER TO TFWorkAreaManager;	// Gestore delle Missioni e delle WorkArea
	MissionStateCase 			: POINTER TO MissionStateCase;	// Stato Delle Missioni 
	AbilitaControlloPHGripPresence 	: BOOL; 	// Se TRUE = Abilita il controllo della fotocellula di presenza materiale sulla pinza
	//AbilitaControlloCoppia 			: BOOL;			// Se TRUE = Disabilita il controllo della coppia
	AbilitaAnticipoDinamico 		: POINTER TO BOOL;				// Se TRUE = Abilitazione dell'anticipo dinamico dei movimienti
	AbilitaCalcoloIngombroOttimizzato   : POINTER TO BOOL;				// Se TRUE = Abilitazione del calcolo degli ingombri utilizzando l'angolo di rotazione attuale della pinza
	GestioneAZoneAbilitata 				: POINTER TO BOOL; //Abilitazione della gestione zone
	AbilitaDepositoPaccoOrrizzonataleConTasteggio : POINTER TO BOOL;
	AbilitaInterpolazioneAssi 	: POINTER TO BOOL; 			// Se TRUE = Abilitazione dell'interpolazione degli assi
	STARTInterpolazioneASSI 	: POINTER TO BOOL;			// Se TRUE = Lancia l'interpolazione degli assi
	AbilitaDisposizionePalletContinua : POINTER TO BOOL; 	// Se TRUE = abilita il deposito dei pallet in modo continuo
	AbilitaForzaturaStatoWAMDaCicloRiposoACicloPrelievo : POINTER TO BOOL; // Se TRUE = forza lo stato del WAM da cilco di riposo a ciclo di prelievo pacco
	AbilitaOffsetInUscitaTasteggioPrelievoPallet : POINTER TO BOOL; // Abilitazione dell'offset in uscita dei tastatori in prelievo pallet con tasteggio
	AbilitaAccostamentoAsseZ : POINTER TO BOOL; // Abilitazione dell'accostamento ell'asse Z.. Se TRUE : Ad una certa quota l'asse si muove in lenta
	AbilitaErroreComunicazioneTrasporti : BOOL; //Abilitazione Errore di comunicazione con i trasporti
	SimulazioneSenzaPalletFalde : BOOL;
	//MaterialeDepositatoSuLinea : POINTER TO BOOL;
	WorkAreaProductionList : POINTER TO ARRAY [1..MAXAREA] OF TFMachinePalletizer_ListaProduzione_WAM;
	RichiestaIngZonaDX : BOOL;
	RichiestaIngZonaSX : BOOL;
END_VAR
VAR_OUTPUT
	CmdExe : CommandExe;
	CmdExd : CommandExe;
	CmdNext : Command;
	CmdLog : CommandLog;
	State : State;
	StateLog : StateLog;
	Error : Error;
	ErrorLog : ErrorLog;
	Warning : Warning;
	WarningLog : WarningLog;
	OUT : TFMachinePalletizer_OUT;
	PalletStackEmpty : INT;
	LayerStackEmpty : INT;
	AllWABusy : INT;
	AssiInterpolati 			: BOOL;
	PinzaInQuotaFuoriIngombroPerTrasporti : BOOL;// la Quota della pinza mi garantisce che sono in fuori ingombro e il ribaltino può ruotare
END_VAR
VAR
	Init : BOOL;
	ParametersArray : ParametersArray;
	CommandExternal : TFCommandExternal;
	Timer : REAL := 1;
	Timeout : REAL := 1;
	i : UINT;
	w : UINT;
	e : UINT;
	j : UINT;
	k : UINT;
	z : INT;
	Step : BOOL;
	Power : UINT;
	TimerWorkFlow : ARRAY[0..MAXWORKFLOW] OF REAL;
	WorkFlow : ARRAY[0..MAXWORKFLOW] OF WorkFlow;
	WorkFlowErrorLog : ARRAY[0..MAXWORKFLOW] OF WorkFlowErrorLog;
	NumeroWF : UINT;//Numero del WorkFlow
	
	
	MAN_Actuator : UINT;
	MAN_Cmd : UINT;
	Timer1000 : REAL := 1;
	HornClock : BOOL;
	HornAck : BOOL;
	
	LGVPhaseStopRequest : BOOL;
	//LoopFlipFlop : BOOL;
	//LFF_X : LREAL;
	//LFF_Y : LREAL;
	//LFF_Z : LREAL;
	//LFF_J : LREAL;
	
	ExternalWaitPositionRequest : BOOL;
	//ValidationResult : INT;
	//NextCommand : INT;
	//NextCode : INT;
	AirAlarmTrig : BOOL;
	Volt24Trig : BOOL;
	BeltSafetyTRIG : BOOL;
	//RADIUS : LREAL;
	ClockLamp : BOOL;
	TimerLamp : REAL := 1;
	TimerComTrasporti : REAL :=1;
	AutoTrig : BOOL;
	AutoToMan : BOOL;
	GateAccesTrig : BOOL;
	GateAcces : BOOL;
	ExecuteStopTilter : BOOL;
	ExecuteStopTilterTRIG : BOOL;
	
	TFPalletizerWorkAreaManagerTF 	: TFPalletizerWorkAreaManagerTF_Lastre;
	TFProgramma_Ciclo_Riposo 		: TFProgramma_Ciclo_Riposo_Lastre;
	TFProgramma_Ciclo_Falda 		: TFProgramma_Ciclo_Falda_Lastre;
	TFProgramma_Ciclo_Lastra 		: TFProgramma_Ciclo_Lastra;
	
	(* Ciclo di lavoro CON interpolazione degli assi *)
	TFCiclo_Di_Riposo 				: TFCiclo_Di_Riposo_Lastre;
	TFCiclo_Prelievo_Falda 			: TFCiclo_Prelievo_Falda;
	TFCiclo_Deposito_Falda 			: TFCiclo_Deposito_Falda;
	TFCiclo_Prelievo_Lastra 		: TFCiclo_Prelievo_Lastra;
	TFCiclo_Deposito_Lastra 		: TFCiclo_Deposito_Lastra;
	//Depalettizzatore	
	//TFCiclo_Prelievo_Lastra_Depalettizzatore 		: TFCiclo_Prelievo_Lastra_Depal;
	TFCiclo_Prelievo_Lastra_Depalettizzatore 		: TFCiclo_Prelievo_Lastra_Depal;//TFCiclo_Prelievo_Lastra;
	TFCiclo_Deposito_Lastra_Depalettizzatore 		: TFCiclo_Deposito_Lastra_Depal;
	TFCiclo_Deposito_Falda_Depalettizzatore 		: TFCiclo_Deposito_Falda_Depal;
	
	(* FB Vari *)
	TFCalcoloTraiettoria 				: TFCalcoloTraiettoriaLastre;// TFCalcoloTraiettoria;
	TFCalcoliFuoriIngombri		 		: TFCalcoliFuoriIngombri;
	TFCalcoloPuntiDiAnticipoDinamici 	: TFCalcoloPuntiDiAnticipoDinamici;
	TFValutaAssiInFinestraDiPassMode 	: TFValutaAssiInFinestraDiPassMode;
	
	AbilitazioCiclo_TEST_STEP 	: BOOL := FALSE; 		//TRUE se in fase di test si vuole eseguire il ciclo a step
	CommandSTEP				: BOOL := FALSE;	 //Comando di step per eseguire il ciclo a step

	CommandSTEPTRIG			: BOOL := FALSE;	// Memoria Comando di step per eseguire il ciclo a step
	STEPCicloDONE 			: BOOL;
	PX_GripPresenceOK       : BOOL;
	ErroreDiInterferenza : UINT;
	WaitPositionRequest : BOOL;
	InWaitPosition : BOOL;
	//DepositoFaldaSuCatastaVuoti : BOOL;
	//Filtro_PX_GripPresence : Signal_Filter;
	PX_GripPresenceFiltrata	: BOOL;
	
	PalletLayerPresence : UINT;
	DepositoPaccoInLenta : BOOL;
	
	//CoppiaPinzaOK : BOOL;
	//TimerControlloCoppiaTRUE : REAL;
	//TimerControlloCoppiaFALSE : REAL;
	//FiltroControlloCoppia : REAL := 200;
	
	ForzaPrelievoPaccoDuranteCicloDiRiposo : BOOL;
	
	TimerPacchi1Minuto : REAL;
	AttivaTimerContaPacchi1Minuto : BOOL;
	AttivaTimerContaPacchi5Minuti : BOOL;
	PacchiPrelevatiIn5MinutiAppoggio : REAL;
	cuontpac : UINT;
	Pacchi1Minuto : uint;
	TimerDone1 : UINT;
	TimerPacchi5Minuti : REAL;
	//RibaltinoPronto : BOOL;
	//RichiestaStartRibaltino : BOOL;
	ResetComandoRibaltinoEseguito : BOOL;
	
	//UltimaWaDepositoPacco : INT;
	//UltimoComandoRibaltino : INT;
	//PHOKDebug : bool;
	//CoppiaOkDebug : BOOL;
	Interpolazione_Assi : TFInterpolazioneAssi.Interpolazione_Assi;
	IndiceForSb : int;
	PinzaInQuotaFuoriIngombro : BOOL;// la Quota della pinza mi garantisce che sono in fuori ingombro

	RitardoEsecuzioneInterpolazione : REAL := 0.008;
	TempoCompensazioneDecelerazione : REAL := 0.03;
	TempoCompensazioneAccelerazione : REAL := 0;
	
	TimerRestCmdRibaltino : REAL;
	
	//ComandoPickPoint : ARRAY[1..10] OF INT;
	//StatoPickPoint : ARRAY[1..10] OF INT;
	//comdRib : INT :=1;
	wfindx : UINT;
	PinzaConProdottoInPresa : BOOL;
	
	TimerONAlternato : REAL;
	TimerOFFAlternato : REAL;
	TimerSirenaOFF_Segnalazioni : REAL;
	In_GiCavallete: UINT;
	OkEstacionFinPiking: BOOL;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Init *)
IF NOT Init THEN
	TFCommandBufferClear(ADR(Cmd));
	TFCommandClear(ADR(CmdNext));
	TFCommandExeClear(ADR(CmdExe));
	TFStateUpdate(ADR(State),StateNOP);
	TFErrorClear(ADR(Error));
	TFWarningClear(ADR(Warning));
	OUT.HomeDone := FALSE;
	AutoToMan := TRUE;
	Timer := 10;
	Timeout := 10;
	OUT.PowerOffTilterReq := FALSE;
	OUT.StopTilterReq := FALSE;
	OUT.PowerOnTilterReq := FALSE;
	OUT.ResetTilterReq := FALSE;
	OUT.StartTilter := FALSE;
	Init := TRUE;
END_IF
PosRobot := 0 ;
RobotWorkAreaCavallete := FALSE ;

IF NuEstacionesPiking > 1  THEN
	MultiplesCavalletesReceta := TRUE ;
ELSE
	MultiplesCavalletesReceta := FALSE ;
END_IF

IF NuEstacionesPiking > 1 AND NuEstacionPiking <> 0 AND WorkAreaState^[NuEstacionPiking].Supporto.Tipologia = CAVALLETTO THEN
	PikingConCavallete := TRUE ;
ELSE
	PikingConCavallete := FALSE ;
END_IF


 
(*IF MultiplesCavalletesReceta THEN 
	IF NuEstacionPiking = 1  THEN 
		NuPosGuiroPiking := NuEstacionPiking + 1 ;
	ELSIF NuEstacionPiking > 1 AND NuEstacionesPiking <  NuEstacionPiking      THEN  
		NuPosGuiroPiking := NuEstacionPiking - 1 ;
	END_IF
	
END_IF *)

WaCavalleteEnPiking := 0 ;
IF MultiplesCavalletesReceta THEN 
	FOR In_GiCavallete := 1 TO MAXAREAPRESENT DO 
		IF PosCavalleteOrdenPikin[In_GiCavallete] = CAVALLETTO THEN
			IF In_GiCavallete = NuEstacionPiking AND In_GiCavallete = 1   THEN
				NuPosGuiroPiking := NuEstacionPiking + 1 ;
			ELSIF  In_GiCavallete = NuEstacionPiking   THEN  
				IF WaCavalleteEnPiking = 0 THEN 
					NuPosGuiroPiking := NuEstacionPiking + 1 ;
					ELSE
					NuPosGuiroPiking := NuEstacionPiking - 1 ;	
				END_IF
			ELSIF  In_GiCavallete <> NuEstacionPiking   THEN  
				WaCavalleteEnPiking := WaCavalleteEnPiking +1 ;	
			END_IF
				
		END_IF
	END_FOR
END_IF

IF NOT MultiplesCavalletesReceta AND  NuEstacionPiking <> 0 AND 
					WorkAreaState^[NuEstacionPiking].Supporto.Tipologia = CAVALLETTO AND
							 PosFinOrdenPikingCaballete = 0  THEN 
	OkEstacionFinPiking := FALSE ;
	CASE NuEstacionPiking OF
		1 :
			FOR In_GiCavallete := (NuEstacionPiking +1) TO MAXAREAPRESENT DO
				IF WorkAreaState^[In_GiCavallete].Supporto.Tipologia <> CAVALLETTO THEN
					PosFinOrdenPikingCaballete := In_GiCavallete ;
					EXIT ;
				END_IF
			END_FOR
			
		2..20 :
			
			FOR In_GiCavallete := (NuEstacionPiking-1)  TO 1 BY -1 DO
				IF WorkAreaState^[In_GiCavallete].Supporto.Tipologia <> CAVALLETTO THEN
					PosFinOrdenPikingCaballete := In_GiCavallete ;
					OkEstacionFinPiking := TRUE ;
					EXIT ;
				END_IF
			END_FOR	
			IF NOT OkEstacionFinPiking THEN 
				FOR In_GiCavallete := (NuEstacionPiking +1)  TO MAXAREAPRESENT  DO
				IF WorkAreaState^[In_GiCavallete].Supporto.Tipologia <> CAVALLETTO THEN
					PosFinOrdenPikingCaballete := In_GiCavallete ;
					OkEstacionFinPiking := TRUE ;
					EXIT ;
				END_IF
			END_FOR	
			END_IF
			
	END_CASE

	ELSE 
		
		IF NuPosGuiroPiking <> 0 THEN 
			PosFinOrdenPikingCaballete := NuPosGuiroPiking ; 
		END_IF
END_IF


FOR In_PosRobot := 1 TO MAXAREAPRESENT DO
	IF TFAsseInFinestra(Posizione_Attuale:= Modules^.AX_X.Ax^.AxRef^.NcToPlc.ActPos ,Posizione_Finale:= WorkArea^[In_PosRobot].X ,FinestraDiControllo := 300) THEN
		PosRobot := In_PosRobot ;
		RobotCentroPosX := TRUE ;	
			IF WorkAreaState^[PosRobot].Supporto.Tipologia = CAVALLETTO THEN
				RobotWorkAreaCavallete := TRUE ;
				
			ELSE
				RobotWorkAreaCavallete := False ;	
			END_IF
		
		 	IF 	 Modules^.AX_J.Ax^.AxRef^.NcToPlc.ActPos <85 THEN 
					PosicionJActual := 0 ;
				ELSIF Modules^.AX_J.Ax^.AxRef^.NcToPlc.ActPos >95 THEN
					 PosicionJActual := 180 ;
				ELSE
					PosicionJActual := 90 ;
				END_IF
		EXIT;
		ELSE
		RobotCentroPosX := FALSE ;		
		
	END_IF
END_FOR 

IF 	 Mission^.JPlace <85 THEN 
	PosicionJDestino := 0 ;
ELSIF Mission^.JPlace >95 THEN
	 PosicionJDestino := 180 ;
ELSE
	PosicionJDestino := 90 ;
END_IF
IF 	 Mission^.JPick <85 THEN 
	PosicionJOrigen := 0 ;
ELSIF Mission^.JPick >95 THEN
	 PosicionJOrigen := 180 ;
ELSE
	PosicionJOrigen := 90 ;
END_IF

IF PosicionJDestino <> PosicionJOrigen  OR PosicionJActual <> PosicionJOrigen THEN 
	AngulosDiferentes := TRUE ;
	ELSE 
	AngulosDiferentes := FALSE ;	
END_IF





AbilitazioCiclo_TEST_STEP := HMI_AbilitazioneCicloAStep;
CommandSTEP := HMI_CommandSTEP OR (AbilitazioCiclo_TEST_STEP AND IN.Mode.ResetRequest);

(* Generic Timer - Add here all your Timers *)

TFTimerCall(ADR(Timer),Cfg.TimeBase);
TFTimerCall(ADR(Timeout),Cfg.TimeBase);
TFTimerCall(ADR(Timer1000),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[0]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[1]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[2]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[3]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[4]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[5]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[6]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[7]),Cfg.TimeBase);
TFTimerCall(ADR(TimerWorkFlow[8]),Cfg.TimeBase);
TFTimerCall(ADR(TimerLamp),Cfg.TimeBase);
//TFTimerCall(ADR(TimerControlloCoppiaTRUE),Cfg.TimeBase);
//TFTimerCall(ADR(TimerControlloCoppiaFALSE),Cfg.TimeBase);
TFTimerCall(ADR(TimerComTrasporti),Cfg.TimeBase);
TFTimerCall(ADR(TimerRestCmdRibaltino),Cfg.TimeBase);

(* External Command *)
CommandExternal(
	Cmd := ADR(Cmd),
	CmdExe := ADR(CmdExe),
	State := ADR(state),
	Error := ADR(Error),
	ErrorLog := ADR(ErrorLog),
	Warning := ADR(Warning),
	WarningLog := ADR(WarningLog),
	Mode := ADR(IN.Mode));

(* External To Buffered Command *)
TFCommandToNext(ADR(Cmd),ADR(CmdNext),ADR(CmdExe),ADR(Cfg),ADR(Error),ADR(ErrorLog),ADR(State));

(* Buffered To Exe Command *)
TFCommandToExecution(ADR(CmdNext),ADR(CmdExe),ADR(Error),ADR(ErrorLog),ADR(State),ADR(CmdLog));

(* Exe Command *)
CASE CmdExe.Code OF

	(* ******************************************************************************************************** *)
	(* Nop *)
	(* ******************************************************************************************************** *)
	CmdNOP:	;

	(* ******************************************************************************************************** *)
	(* Stop *)
	(* ******************************************************************************************************** *)
	CmdSTOP:
		CASE CmdExe.CmdCase OF
			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StateSTOP_RUN);
				TFTimerSet(ADR(Timer),10,TRUE);
				TFTimerSet(ADR(Timeout),5000,TRUE);
				OUT.StartHorn := FALSE;
				OUT.PowerOffTilterReq := FALSE;
				OUT.StopTilterReq := FALSE;
				OUT.PowerOnTilterReq := FALSE;
				OUT.ResetTilterReq := FALSE;
				OUT.StartTilter := FALSE;
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
			
			(* Case 1 - Wait All WorkFlow=FALSE *)
			1:	IF (*NOT WorkFlow[0].Enable AND
					NOT WorkFlow[1].Enable AND
					NOT WorkFlow[2].Enable AND
					NOT WorkFlow[3].Enable AND
					NOT WorkFlow[4].Enable AND
					NOT WorkFlow[5].Enable AND
					NOT WorkFlow[6].Enable AND
					NOT WorkFlow[7].Enable AND
					NOT WorkFlow[8].Enable*)
					TFWorkflowsAllEnableOrDisable(ADR(WorkFlow),FALSE) OR
					TFTimerDone(ADR(Timer)) THEN
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				END_IF
			
			(* Case 2 - Invio comando di STOP a tuttti i moduli *)
			2:	//OUT.HomeDone := FALSE;
				//Disabilito tutti i WF				
				FOR wfindx := 0 TO MAXWORKFLOW DO
					WorkFlow[wfindx].Enable := FALSE;
				END_FOR
				TFParametersArrayClear(ADR (ParametersArray));
				TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
				OUT.StopTilterReq := ExecuteStopTilter;
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

			(* Case 3 - Attesa che tutti i moduli abbiano completato il comando *)
			3:	IF TFPalletizerModulesCheckState(StateSTOP_END,Modules) THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					TFError(ErrTOSTOP,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

			(* Case 100 *)
			100:TFStateUpdate(ADR(State),StateSTOP_END);
				TFCommandExeClear(ADR(CmdExe));

			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE
	
	(* ******************************************************************************************************** *)
	(* Error Reset *)
	(* ******************************************************************************************************** *)
	CmdRESET:
		CASE CmdExe.CmdCase OF
			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StateRESET_RUN);
				TFTimerSet(ADR(Timeout),1000,TRUE);
				OUT.StartHorn := FALSE;
				AirAlarmTrig := FALSE;
				Volt24Trig  := FALSE;
				BeltSafetyTRIG := FALSE;
				PalletStackEmpty := 0;
				LayerStackEmpty := 0;
				(* Se l'errore di interferenza è maggiore di 0, assegno alla traiettoria e alla missione dei i valori del punto di riposo, 
				in questo modo sbianco le eventuali quote non ammesse *)
				IF ErroreDiInterferenza > 0 THEN
					//X_Riposo	:= WorkPickPoint^[1].Xv;
					//Y_Riposo	:= WorkPickPoint^[1].Yv;
					//Z_Riposo	:= ZRESTPOSITION;
					//J_Riposo	:= WorkPickPoint^[1].Jv;
					//K_Riposo	:= KRESTPOSITION; 
					
					{info 'TODO: Valorizzar quote di riposo'} 
					Traiettoria^.EndPoint.X := X_Riposo;
					Traiettoria^.EndPoint.Y := Y_Riposo;
					Traiettoria^.EndPoint.Z := Z_Riposo;
					Traiettoria^.EndPoint.J := J_Riposo;
					Traiettoria^.EndPoint.K := K_Riposo;
					
					Mission^.PPick			:= PICKPOINT1;
					Mission^.TPick 			:= TPICK_NOT_DEFINED;
					Mission^.XPick 			:= X_Riposo;
					Mission^.YPick 			:= Y_Riposo;
					Mission^.ZPick 			:= Z_Riposo;
					Mission^.JPick 			:= J_Riposo;
					
					Mission^.XPlace := X_Riposo;
					Mission^.YPlace := Y_Riposo;
					Mission^.ZPlace := Z_Riposo;
					Mission^.JPlace := J_Riposo;
					
					ErroreDiInterferenza := 0;
				END_IF
							
				
				LGVError := 0;
				GateAccessError := 0;
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

			(* Case 1 - Invio comando di reset a tuttti i moduli*)
			1:	TFParametersArrayClear(ADR (ParametersArray));
				TFPalletizerModulesCommandSend(CmdRESET,ParametersArray,Modules);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

			(* Case 2 - Attesa che tutti i moduli abbiano completato il comando *)
			2:	
				IF TFPalletizerModulesCheckState(StateRESET_END,Modules) THEN
						TFCommandCase(ADR(CmdExe),99,CommandCase_JMP);
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					OUT.ResetTilterReq := FALSE;
					TFError(ErrTORESET,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

			(* Case 99 *)
			99:	
				FOR i:= 0 TO MAXWORKFLOW DO
					IF WorkFlow[i].WFCase = StateWF_ERROR THEN
						WorkFlow[i].WFCase := 0;
					END_IF
					IF WorkFlow[i].State = StateWF_ERROR THEN
						WorkFlow[i].State := 0;
					END_IF
				END_FOR
				TFErrorClear(ADR(Error));
				TFWarningClear(ADR(Warning));
				TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				
			(* Case 100 *)
			100:TFStateUpdate(ADR(State),StateRESET_END);
				TFCommandExeClear(ADR(CmdExe));

			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE

	(* ******************************************************************************************************** *)
	(* Power *)
	(* ******************************************************************************************************** *)
	CmdPOWER:
		CASE CmdExe.CmdCase OF
			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StatePOWER_RUN);
				TFTimerSet(ADR(Timeout),2500,TRUE);

				IF TFCommandParRead(CmdExe.Cmd.Parameter,ADR(ParametersArray),1) THEN
					Power := STRING_TO_UINT(ParametersArray.Parameters[0]);
				ELSE
					TFError(ErrCMDPARNUM,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					RETURN;
				END_IF

				IF Power = 1 THEN
					TFCommandCase(ADR(CmdExe),10,CommandCase_JMP);
				ELSE
					TFCommandCase(ADR(CmdExe),20,CommandCase_JMP);
				END_IF
				
			(* Case 10 - Power On *)
			10: OUT.PowerActive := TRUE;
				OUT.PowerActiveSIMULAZIONE := FALSE;
				IF IN.PowerOk THEN
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					OUT.PowerActive := FALSE;
					TFError(ErrTOPOWERON,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF
			
			(* Case 11 - Invio comando di Power *)
			11:	TFParametersArrayClear(ADR (ParametersArray));
				ParametersArray.Parameters[0] := '1';
				TFPalletizerModulesCommandSend(CmdPOWER,ParametersArray,Modules);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
			
			(* Case 12 - Attesa che tutti i moduli siano in Power *)
			12:IF TFPalletizerModulesCheckState(StatePOWER_END,Modules) THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				ELSIF TFPalletizerIsModuleError(Modules) THEN
					OUT.PowerActive := FALSE;
					TFError(ErrNOPOWER,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					OUT.PowerActive := FALSE;
					TFError(ErrTOPOWERON,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF
			
			(* Case 20 - Power Off *)
			20:	CmdExe.RapidStopRequest := 1;
				CmdExe.PhaseStopRequest := 1;
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
			
			(* Case 21 *)
			21:					
				//Disabilito tutti i WF				
				FOR wfindx := 0 TO MAXWORKFLOW DO
					WorkFlow[wfindx].Enable := FALSE;
				END_FOR

				TFParametersArrayClear(ADR (ParametersArray));
				TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
			
			(* Case 22 *)
			22: IF TFPalletizerModulesCheckState(StateSTOP_END,Modules) THEN
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					TFError(ErrTOSTOP,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

			(* Case 23 *)
			23:	TFParametersArrayClear(ADR (ParametersArray));
				ParametersArray.Parameters[0] := '0';
				TFPalletizerModulesCommandSend(CmdPOWER,ParametersArray,Modules);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
			
			(* Case 24 *)
			24:	IF TFPalletizerModulesCheckState(StatePOWER_END,Modules) THEN
					OUT.PowerActive := FALSE;
					OUT.PowerOffTilterReq := FALSE;
					OUT.PowerActiveSIMULAZIONE := FALSE;
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				ELSIF TFPalletizerIsModuleError(Modules) THEN
					OUT.PowerActive := FALSE;
					TFError(ErrNOPOWER,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					OUT.PowerOffTilterReq := FALSE;
					OUT.PowerActive := FALSE;
					TFError(ErrTOPOWEROFF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF
				
			(* Case 25 - Power On *)
			25: OUT.PowerActive := FALSE;
				IF NOT IN.PowerOk THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				ELSIF TFTimerDone(ADR(Timeout)) THEN
					OUT.PowerActive := FALSE;
					TFError(ErrTOPOWEROFF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

			(* Case 100 *)
			100:TFStateUpdate(ADR(State),StatePOWER_END);
				TFCommandExeClear(ADR(CmdExe));

			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE
	
	(* ******************************************************************************************************** *)
	(* Home *)
	(* ******************************************************************************************************** *)
	CmdHOME:
		CASE CmdExe.CmdCase OF
			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StateHOME_RUN);
				TFTimerSet(ADR(Timeout),60000,TRUE);
				OUT.HomeDone := FALSE;
				TFCommandCase(ADR(CmdExe),10,CommandCase_JMP);

			(* Case 10 *)
			10:	TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

				(* Check Modules Error *)
				IF TFPalletizerIsModuleError(Modules) THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				END_IF

			(* Case 11 - Start Horn *)
			11:	TFTimerSet(ADR(Timer),1000,NOT OUT.StartHorn);
				OUT.StartHorn := TRUE;
				IF TFTimerDone(ADR(Timer)) THEN
					OUT.StartHorn := FALSE;
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				END_IF
				IF CmdExe.PhaseStopRequest > 0 THEN
					OUT.StartHorn := FALSE;
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				END_IF

			(* Case 12 - Homing *)
			12:	WorkFlow[0].Enable := TRUE;
				TFWorkFlowCase(ADR(WorkFlow[0]),0,WorkflowCase_JMP);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

			(* Case 13 - Wait Homing END *)
			13:	IF WorkFlow[0].State = StateWF_END THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				ELSIF WorkFlow[0].WFCase = StateWF_ERROR THEN
					WorkFlow[0].Enable := FALSE;
					TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

			(* Case 100 *)
			100:TFStateUpdate(ADR(State),StateHOME_END);
				TFCommandExeClear(ADR(CmdExe));

			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE


	(* ******************************************************************************************************** *)
	(* Manual *)
	(* ******************************************************************************************************** *)
	CmdMAN:
		CASE CmdExe.CmdCase OF
			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StateMAN_RUN);
				TFTimerSet(ADR(Timeout),10,TRUE);
				//OUT.HomeDone := FALSE;
				IF TFCommandParRead(CmdExe.Cmd.Parameter,ADR(ParametersArray),2) THEN
					MAN_Actuator	:= STRING_TO_UINT(ParametersArray.Parameters[0]);
					MAN_Cmd		:= STRING_TO_UINT(ParametersArray.Parameters[1]);
				ELSE
					TFError(ErrCMDPARNUM,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					RETURN;
				END_IF

				CASE MAN_Actuator OF
					(* Case 0..99 for Actuators *)
					(* Case 100..199  for Axis *)
					(* Case 200.....  for Modules *)

					(* Case Nop *)
					0: 	;

					(* Case 1:  *)
					1:	CASE MAN_Cmd OF
							0:	;
							
							ELSE
								TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						END_CASE;

					(* Case 200:  Module Robot *)
					200:CASE MAN_Cmd OF
							0:	;
							
							
							1: 
								TFCommandCase(ADR(CmdExe),1000,CommandCase_JMP);
							ELSE
								TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						END_CASE;

					ELSE
						TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_CASE

				IF CmdExe.CmdCase = 0 THEN
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				END_IF

			(* Case 1 *)
			1: 	IF (MAN_Cmd = 0) OR TFTimerDone(ADR(Timeout)) THEN
					(* Clear All Output Here *)
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
					TFCommandExeClear(ADR(CmdExe));
				END_IF
			
			(* *)	
			201:
				
				TFCommandCase(ADR(CmdExe),1000,CommandCase_JMP);
			
			(* Case 1000 *)
			1000:
				TFStateUpdate(ADR(State),StateMAN_END);
				TFCommandExeClear(ADR(CmdExe));
			
			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE;


	CmdCICLORIPOSO:	
		CASE CmdExe.CmdCase OF

			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StateCICLORIPOSO_RUN);
				TFCommandCase(ADR(CmdExe),10,CommandCase_JMP);

			(* Case 10 *)
			10:	TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				
				(* Check Modules Power *)
				IF NOT IN.PowerOk OR NOT TFPalletizerModulesCheckPowerActive(Modules) THEN
					TFError(ErrMACHINEPALLETIZER_MISSINGPOWER,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

				(* Check Modules Error *)
				IF TFPalletizerIsModuleError(Modules) THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				END_IF

			(* Case 11 - Start Horn *)
			11:	TFTimerSet(ADR(Timer),3000,NOT OUT.StartHorn);
				OUT.StartHorn := TRUE;
				IF TFTimerDone(ADR(Timer)) THEN
					OUT.StartHorn := FALSE;
					TFCommandCase(ADR(CmdExe),14,CommandCase_JMP);
				END_IF
				IF CmdExe.RapidStopRequest > 0 OR
					CmdExe.PhaseStopRequest > 0 THEN
					OUT.StartHorn := FALSE;
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				END_IF;

			(* Case 14 - Attivazione e inizializzazione del Workflow*)
			14:	WorkFlow[2].Enable := TRUE;
				TFWorkFlowCase(ADR(WorkFlow[2]),0,WorkflowCase_JMP);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

			(* Case 15 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
			15:	IF CmdExe.RapidStopRequest > 0 OR
					CmdExe.PhaseStopRequest > 0 OR
					(NOT WorkFlow[2].Enable OR WorkFlow[2].WFCase = StateWF_ERROR) THEN
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				END_IF;

			(* Case 16 - Wait WF End *)
			16: IF (NOT WorkFlow[2].Enable OR WorkFlow[2].State = StateWF_END OR WorkFlow[2].WFCase = StateWF_ERROR) THEN
				WorkFlow[2].Enable := FALSE;
				IF WorkFlow[2].WFCase = StateWF_ERROR THEN
					IF Warning.Code <> ErrNULL THEN
						TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					ELSE
						TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					END_IF
				ELSE
					(*Invio comando di stop ai moduli*)
					TFParametersArrayClear(ADR (ParametersArray));
					TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
					IF TFIsModuleWarning(Warning) THEN
						TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					ELSE
						TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
					END_IF
				END_IF
			END_IF	

			(* End Case *)
			100:TFStateUpdate(ADR(State),StateCICLORIPOSO_END);
				TFCommandExeClear(ADR(CmdExe));

			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE

	(* ******************************************************************************************************** *)
	(* DO *)
	(* ******************************************************************************************************** *)
	CmdDO:
		CASE CmdExe.CmdCase OF

			(* Case 0 *)
			0: 	TFStateUpdate(ADR(State),StateDO_RUN);
				TFCommandCase(ADR(CmdExe),10,CommandCase_JMP);

			(* Case 10 *)
			10:	TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				
				(* Check Modules Power *)
				IF NOT IN.PowerOk OR NOT TFPalletizerModulesCheckPowerActive(Modules) THEN
					TFError(ErrMACHINEPALLETIZER_MISSINGPOWER,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

				(* Check Modules Error *)
				IF TFPalletizerIsModuleError(Modules) THEN
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				END_IF

			(* Case 11 - Start Horn *)
			11:	TFTimerSet(ADR(Timer),3000,NOT OUT.StartHorn);
				OUT.StartHorn := TRUE;
				IF TFTimerDone(ADR(Timer)) THEN
					OUT.StartHorn := FALSE;
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				END_IF
				IF CmdExe.PhaseStopRequest > 0 THEN
					OUT.StartHorn := FALSE;
					TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
				END_IF;

			(* Case 12 - Homing *)
			12:	WorkFlow[0].Enable := TRUE;
				OUT.StartTilter := TRUE;
				TFWorkFlowCase(ADR(WorkFlow[0]),0,WorkflowCase_JMP);
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				
			(* Case 13 - Wait Homing END *)
			13:	IF WorkFlow[0].State = StateWF_END THEN
					IF CmdExe.PhaseStopRequest > 0 THEN
						TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
					ELSE
						TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
					END_IF
				ELSIF WorkFlow[0].WFCase = StateWF_ERROR THEN
					WorkFlow[0].Enable := FALSE;
					TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF;

			(* Case 14 *)
			14:	WorkFlow[1].Enable := TRUE;
				TFWorkFlowCase(ADR(WorkFlow[1]),0,WorkflowCase_JMP);	
				TFCommandCase(ADR(CmdExe),1,CommandCase_INC);

			(* Case 15 - Wait Stop Request *)
			15:	IF CmdExe.PhaseStopRequest > 0 THEN
					TFCommandCase(ADR(CmdExe),1,CommandCase_INC);
				END_IF;

			(* Case 16 - Wait WF End *)
			16: IF TFIsWorkflowDisableOrEndedOrError(NumWFPresence:=MAXWORKFLOW,ADR(WorkFlow)) THEN //Verifico che tutti i WF non siano attivi, nel caso attendo che lo siano
					//Disabilito tutti i WF				
					FOR wfindx := 0 TO MAXWORKFLOW DO
						WorkFlow[wfindx].Enable := FALSE;
					END_FOR
					
					(*Invio comando di stop ai moduli*)
					TFParametersArrayClear(ADR (ParametersArray));
					TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
	
					IF TFIsWorkflowError(ADR(WorkFlow)) THEN //Valuto se almento un WF è in errore
						IF Warning.Code <> ErrNULL THEN
							TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
							TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
						ELSE
							TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
							TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
						END_IF
					ELSE
						IF TFIsModuleWarning(Warning) THEN
							TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
							TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
						ELSE
							TFCommandCase(ADR(CmdExe),100,CommandCase_JMP);
						END_IF
					END_IF
				END_IF	

			(* End Case *)
			100:TFStateUpdate(ADR(State),StateDO_END);
				TFCommandExeClear(ADR(CmdExe));

			ELSE
				TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		END_CASE

	ELSE
		TFError(ErrNOCMD,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	

END_CASE;

(*---------------------------------------------------------*)
(* Descrizione WorkFlow *)
(*---------------------------------------------------------*)
(* 
	-	WF0: WF di Gestione Ciclo di Home
	-	WF1: WF Principale
	-	WF2: WF Ciclo di Riposo
	-	WF3: WF Ciclo Prelievo Pallet
	-	WF4: WF Ciclo Deposito Pallet
	-	WF5: WF Ciclo Prelievo Falda
	-	WF6: WF Ciclo Deposito Falda
	-	WF7: WF Ciclo Prelievo Pacco
	-	WF8: WF Ciclo Deposito Pacco                       *)

(*---------------------------------------------------------*)
(*---------------------------------------------------------*)

(*-------------------------------------------------------------------------------------------*)		
(* WorkFlow 0 - Homing *)
(*-------------------------------------------------------------------------------------------*)
IF WorkFlow[0].Enable THEN

	CASE WorkFlow[0].WFCase OF

		(* Case 0 *)
		0: 	WorkFlow[0].State := StateWF_RUN;
			TFTimerSet(ADR(TimerWorkFlow[0]),2000,TRUE);
			TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);

		(* Case 1 *)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				CmdExe.PhaseStopRequest > 0 THEN
				TFWorkFlowCase(ADR(WorkFlow[0]),100,WorkflowCase_JMP);
			ELSE
				(* Check Modules Error *)
				IF TFPalletizerIsModuleError(Modules) THEN
						CmdExe.PhaseStopRequest := 1;
						//OUT.HomeDone := FALSE;
						TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
				ELSE
					IF NOT OUT.HomeDone OR (NOT OUT.HomeDone AND 
						(NOT Modules^.AX_X.Ax^.AxRef^.Status.Homed OR
						NOT Modules^.AX_Y.Ax^.AxRef^.Status.Homed OR
						NOT Modules^.AX_Z.Ax^.AxRef^.Status.Homed OR
						NOT Modules^.AX_J.Ax^.AxRef^.Status.Homed)) THEN
						
							TFWorkFlowCase(ADR(WorkFlow[0]),25,WorkflowCase_JMP);
					ELSE
						OUT.HomeDone := TRUE;
						TFWorkFlowCase(ADR(WorkFlow[0]),90,WorkflowCase_JMP);
					END_IF
				END_IF
			END_IF;

		(* Case 10 *)
		10:	
			(* Stato delle piazzole: valuto se sono tutte occupate in modo da segnalarlo all'operatore mediante lampeggio *)
			//////AllWABusy := TFCheckPalletFull(WorkArea:=WorkArea,WorkAreaState:=WorkAreaState,WorkPickPointState:=WorkPickPointState,Forming:=Forming); 
			(* Reset stati e missioni *)
			Mission^.State := MISSION_STATE_NOP;
			WorkAreaManager^.State := WAMANAGER_NOP;
			Ciclo_Di_Riposo.Stato			:= ANNULLATO;
			Ciclo_Prelievo_Lastra.Stato 	:= ANNULLATO;
			//Ciclo_Pelievo_Pallet.Stato 	:= ANNULLATO;
			Ciclo_Pelievo_Falda.Stato 		:= ANNULLATO;
			Ciclo_Deposito_Lastra.Stato 	:= ANNULLATO;
			//Ciclo_Deposito_Pallet.Stato 	:= ANNULLATO;
			Ciclo_Deposito_Falda.Stato 	:= ANNULLATO;
			ProductOnGripper 				:= KNOPRODUCT;
			TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);

		(* Case 11 *)
		11:	TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);
		
		(* Case 12 *)
		12:
			TFParametersArrayClear(ADR(ParametersArray));
			TFCommandSend(CmdHOME,ParametersArray,Modules^.AX_Z.Cmd);
			TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);
			
		(* Case 13 *)	
		13:	IF TFStateCodeGet(Modules^.AX_Z.State) = StateHOME_END THEN
				TFParametersArrayClear(ADR(ParametersArray));
				ParametersArray.Parameters[0] := '100';
				ParametersArray.Parameters[1] := '13';
				Modules^.AX_Y.AxisPar^.Quota_Destinazione := WorkSpace^.Y/2 + OffSetPosYReposo;
				TFCommandSend(CmdMAN,ParametersArray,Modules^.AX_Y.Cmd);
				TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);
			ELSIF CmdExe.RapidStopRequest > 0 OR TFPalletizerIsModuleError(Modules) THEN
				CmdExe.PhaseStopRequest := 1;
				CmdExe.RapidStopRequest := 1;
				TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
			END_IF
			
		(* Case 14 *)
		14:
			IF TFStateCodeGet(Modules^.AX_Y.State) = StateMAN_END THEN
				TFCommandSend(CmdHOME,ParametersArray,Modules^.AX_X.Cmd);
				TFCommandSend(CmdHOME,ParametersArray,Modules^.AX_J.Cmd);
				TFCommandSend(CmdHOME,ParametersArray,Modules^.Pinza.Cmd);
				TFWorkFlowCase(ADR(WorkFlow[0]),20,WorkflowCase_JMP);
			ELSIF CmdExe.RapidStopRequest > 0 OR TFPalletizerIsModuleError(Modules) THEN
				CmdExe.PhaseStopRequest := 1;
				CmdExe.RapidStopRequest := 1;
				TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
			END_IF
	
		(* Case 20 *)
		20:	IF TFStateCodeGet(Modules^.AX_X.State) = StateHOME_END AND
			TFStateCodeGet(Modules^.AX_J.State) = StateHOME_END AND 
			TFStateCodeGet(Modules^.Pinza.State) = StateHOME_END THEN
				TFCommandSend(CmdHOME,ParametersArray,Modules^.AX_Y.Cmd);
				TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);
			ELSIF CmdExe.RapidStopRequest > 0 OR TFPalletizerIsModuleError(Modules) THEN
				CmdExe.PhaseStopRequest := 1;
				TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
			END_IF
			
		(* Case 21 *)
		21:	IF TFStateCodeGet(Modules^.AX_Y.State) = StateHOME_END  THEN
				TFWorkFlowCase(ADR(WorkFlow[0]),1,WorkflowCase_INC);
			ELSIF CmdExe.RapidStopRequest > 0 OR TFPalletizerIsModuleError(Modules)  THEN
				CmdExe.PhaseStopRequest := 1;
				TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
			END_IF
			
		(* Case 22 - *)
		22:	TFWorkFlowCase(ADR(WorkFlow[0]),90,WorkflowCase_JMP);
		
		(* Case 25 - Eseguo Home Direct *)
		25:
			TFParametersArrayClear(ADR(ParametersArray));
			ParametersArray.Parameters[0] := 'TRUE';//Il tipo di homing è HomeDirect
			TFPalletizerModulesCommandSend(CmdHOME,ParametersArray,Modules);
			TFWorkFlowCase(ADR(WorkFlow[0]),26,WorkflowCase_JMP);
			IF CmdExe.RapidStopRequest > 0 OR TFPalletizerIsModuleError(Modules)  THEN
				CmdExe.PhaseStopRequest := 1;
				CmdExe.RapidStopRequest := 1;
				TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
			END_IF
		
		(* Case 26 - Attesa esecuzione HomeDirect *)
		26:	IF TFPalletizerModulesCheckState(StateHOME_END,Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[0]),90,WorkflowCase_JMP);
			ELSIF CmdExe.RapidStopRequest > 0 OR TFPalletizerIsModuleError(Modules)  THEN
				CmdExe.PhaseStopRequest := 1;
				TFWorkFlowCase(ADR(WorkFlow[0]),StateWF_ERROR,WorkflowCase_JMP);
			END_IF
			
		(* Case 90 - HomeDone *)
		90:	
			//Faccio partire tutti i WF dal case 0				
			FOR wfindx := 1 TO MAXWORKFLOW DO
				TFWorkFlowCase(ADR(WorkFlow[wfindx]),0,WorkflowCase_JMP);
			END_FOR
			
			IF NOT IN.PX_WorkArea[1] THEN
			// Pulisco piazzola in seguito ad estrazione
				TFClearWorkAreaArray(WorkArea,WorkAreaState,1);
			END_IF
			
			TFWorkFlowCase(ADR(WorkFlow[0]),94,WorkflowCase_JMP);
			
		(* Case 91 - Clear WorkArea *)
		
		91:	FOR k:= 1 TO MAXAREAPRESENT DO//(MAXAREA/2) DO
				IF NOT IN.PX_WorkArea[k] THEN
					// Pulisco piazzola in seguito ad estrazione
					TFClearWorkAreaArray(WorkArea,WorkAreaState,k);
				ELSE
					// preparo la piazzola solo se di tipo catasta pallet o layer	
					(*IF WorkArea^[k].Typology = TYPOLOGY_STACK OR WorkArea^[k].Typology = TYPOLOGY_LAYER  THEN
						//TFClearWorkAreaStack(WorkArea,WorkAreaState,k);
						IF (AutoToMan OR GateAcces) AND WorkArea^[k].Typology = TYPOLOGY_LAYER THEN
							WorkAreaState^[k].Learn_Z := ALTEZZA_CATASTA_FALDE;
							WorkAreaState^[k].Learned_Z := WorkAreaState^[k].Learn_Z;
							WorkAreaState^[k].H := ALTEZZA_CATASTA_FALDE;
							WorkAreaState^[k].DoLearn_Z := 1;	// Apprendimento da effettuare
						ELSIF ((AutoToMan OR GateAcces) AND WorkArea^[k].Typology = TYPOLOGY_STACK) OR (WorkAreaState^[k].H = 0 AND WorkArea^[k].Typology = TYPOLOGY_STACK) THEN	
							WorkAreaState^[k].Learn_Z := ALTEZZA_CATASTA_VUOTI;
							WorkAreaState^[k].Learned_Z := WorkAreaState^[k].Learn_Z;
							WorkAreaState^[k].H := ALTEZZA_CATASTA_VUOTI;
							WorkAreaState^[k].DoLearn_Z := 1;	// Apprendimento da effettuare						
						END_IF
					ELSIF WorkArea^[k].Typology = TYPOLOGY_PALLET AND Mission^.State = MISSION_STATE_NOP THEN
						IF WorkArea^[k].Enable <> 0 AND (WorkAreaState^[k].State = WORKAREA_STATE_FREE_DISABLED OR WorkAreaState^[k].State = WORKAREA_STATE_FREE_WORKING) THEN
							CmdExe.PhaseStopRequest := 1;
							WorkFlow[0].Enable := FALSE;
							TFError(ErrPALLETALREADYPRESENT,k,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						END_IF
					END_IF*)
				END_IF
			END_FOR
			TFWorkFlowCase(ADR(WorkFlow[0]),94,WorkflowCase_JMP);
			
			(* Case 94 - Clear WorkArea seconda metà *)
			94:
				PalletStackEmpty := 0;
				LayerStackEmpty := 0;
				GateAcces := FALSE;
				IF QuotaFuoriIngombro_X_AVUOTO = 0 THEN
					QuotaFuoriIngombro_X_AVUOTO := WorkPickPoint^[1].X;
				END_IF
				IF QuotaFuoriIngombro_Y_AVUOTO = 0 THEN
					QuotaFuoriIngombro_Y_AVUOTO := WorkPickPoint^[1].Y;
				END_IF
				IF QuotaFuoriIngombro_Z_AVUOTO = 0 THEN
					QuotaFuoriIngombro_Z_AVUOTO := WorkPickPoint^[1].Z + 300;
				END_IF
				//IF QuotaFuoriIngombro_J_AVUOTO = 0 THEN
				//	QuotaFuoriIngombro_J_AVUOTO := 90;
				//END_IF
				(* Inizializzo le quote di sicurezza ad un valore fittizzio elevato in modo da evitare possibili collisioni in caso di errore di calcolo.. NON dovrebbe mai accadere *)
				ErroreDiInterferenza := TFControlloInterferenza( Traiettoria := Traiettoria,
																WorkSpace := WorkSpace,
																WorkFootprint := WorkFootprint,
																WorkPickPoint := WorkPickPoint,
																WorkArea := WorkArea,
																Pallet := Pallet,
																Layer := Layer,
																Forming := Forming,
																Mission := Mission,
																WorkAreaManager := WorkAreaManager,
																ModuleAX_X := ADR(Modules^.AX_X),
																ModuleAX_Y := ADR(Modules^.AX_Y),
																ModuleAX_Z := ADR(Modules^.AX_Z),
																ModuleAX_J := ADR(Modules^.AX_J));
				
				//QuotaFuoriIngombro_Z_AVUOTO 	:= WorkSpace^.Z - 100;
				//QuotaFuoriIngombro_Z_ConFALDA 	:= WorkSpace^.Z - 100;
				//QuotaFuoriIngombro_Z_ConPEZZO 	:= WorkSpace^.Z - 100;
				//QuotaFuoriIngombro_Z_ConPALLET 	:= WorkSpace^.Z - 100;
				IF ErroreDiInterferenza > 0 THEN
				(* Se l'errore di interferenza è maggiore di 0, assegno alla traiettoria e alla missione dei i valori del punto di riposo, 
					in questo modo sbianco le eventuali quote non ammesse *)	
					CASE TIPOLOGIA_FUNZIONAMENTO_MACCHINA OF

						FUNZIONAMENTO_PALLETTIZZATORE:
							X_Riposo	:= WorkPickPoint^[1].X;
							Y_Riposo	:= WorkPickPoint^[1].Y + Dimensioni_Pinza.Larghezza;
							Z_Riposo	:= WorkPickPoint^[1].Z + OffsetSicurezza.Z.Avuoto;
							J_Riposo	:= 90;
						FUNZIONAMENTO_DEPAL:

							X_Riposo	:= WorkArea^[1].X;
							Y_Riposo	:= Workarea^[1].Y;
							Z_Riposo	:= 2000;                           
							J_Riposo	:= 90;                             

					
					END_CASE
			


					
					Traiettoria^.EndPoint.X := X_Riposo;
					Traiettoria^.EndPoint.Y := Y_Riposo;
					Traiettoria^.EndPoint.Z := Z_Riposo;
					Traiettoria^.EndPoint.J := J_Riposo;
					
					Mission^.PPick			:= PICKPOINT1;
					Mission^.TPick 			:= TPICK_NOT_DEFINED;
					Mission^.XPick 			:= X_Riposo;
					Mission^.YPick 			:= Y_Riposo;
					Mission^.ZPick 			:= Z_Riposo;
					Mission^.JPick 			:= J_Riposo;
					
					Mission^.XPlace := X_Riposo;
					Mission^.YPlace := Y_Riposo;
					Mission^.ZPlace := Z_Riposo;
					Mission^.JPlace := J_Riposo;
					ErroreDiInterferenza := 0;
				END_IF
				
				TFWorkFlowCase(ADR(WorkFlow[0]),100,WorkflowCase_JMP);
				
		(* Case 100 *)
		(* WorkFlow END *)
		100:WorkFlow[0].State := StateWF_END;
			WorkFlow[0].Enable := FALSE;
			OUT.HomeDone := TRUE;
			AutoToMan := FALSE;
			AssiInterpolati := FALSE;
			TFWorkFlowCase(ADR(WorkFlow[0]),0,WorkflowCase_JMP);

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[0]),ADR(WorkFlowErrorLog[0]));
			WorkFlow[0].Enable := FALSE;

		ELSE
			TFWorkFlowError(ADR(WorkFlow[0]),ADR(WorkFlowErrorLog[0]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));

	END_CASE;
		
END_IF

(*-------------------------------------------------------------------------------------------*)		
(* WorkFlow 1 -  *)
(*-------------------------------------------------------------------------------------------*)
IF WorkFlow[1].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[1].WFCase OF

		(* Case 0 *)
		0: 	WorkFlow[1].State := StateWF_RUN;
			TFWorkFlowCase(ADR(WorkFlow[1]),1,WorkflowCase_INC);

		(* Case 1 *)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				CmdExe.PhaseStopRequest > 0 THEN
				TFWorkFlowCase(ADR(WorkFlow[1]),100,WorkflowCase_JMP);
			ELSE
				(* Check Modules Error *)
				IF CmdExe.RapidStopRequest > 0 OR
					TFPalletizerIsModuleError(Modules) THEN
						TFParametersArrayClear(ADR (ParametersArray));
						TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
						//CmdExe.PhaseStopRequest := 1;
						WorkFlow[1].Enable := FALSE;
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[1]),9,WorkflowCase_JMP);	
				END_IF
			END_IF;
			
		(* Case 9 - Controllo che tutti i cicli siano ANNULLATI oppoure TERMINATI.. 
			Se sono INTERROTTI genero allarme affinchè in manuale, non aprono la pinza per annullare TUTTI i cicli!!*)	
		9:	 IF ((Ciclo_Prelievo_Lastra.Stato 	= ANNULLATO OR Ciclo_Prelievo_Lastra.Stato 	= TERMINATO) AND
				(Ciclo_Pelievo_Falda.Stato 		= ANNULLATO OR Ciclo_Pelievo_Falda.Stato	= TERMINATO) AND
				(Ciclo_Deposito_Lastra.Stato	= ANNULLATO OR Ciclo_Deposito_Lastra.Stato 	= TERMINATO) AND
				(Ciclo_Deposito_Falda.Stato		= ANNULLATO OR Ciclo_Deposito_Falda.Stato 	= TERMINATO) AND 
				(Ciclo_Di_Riposo.Stato			= ANNULLATO OR Ciclo_Di_Riposo.Stato 		= TERMINATO) AND
				(Ciclo_Prelievo_Lastra_Depal.Stato = ANNULLATO OR Ciclo_Prelievo_Lastra_Depal.Stato = TERMINATO) AND
				(Ciclo_Deposito_Lastra_Depal.Stato = ANNULLATO OR Ciclo_Deposito_Lastra_Depal.Stato = TERMINATO OR (Ciclo_Deposito_Lastra_Depal.Passo = 56 AND Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO)) AND
				(Ciclo_Deposito_Falda_Depal.Stato = ANNULLATO OR Ciclo_Deposito_Falda_Depal.Stato = TERMINATO)) THEN
				WaitPositionRequest := FALSE;
				IF Mission^.State = MISSION_STATE_NOP THEN
					MissionStateCase^.NCase := 0;
					MissionStateCase^.Mission := MISSION_STATE_NOP;
				END_IF
				TFWorkFlowCase(ADR(WorkFlow[1]),1,WorkflowCase_INC);
			ELSE
				TFError(ErroreMANCATO_RESET_MISSIONI,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				CmdExe.RapidStopRequest := 1;
				WorkFlow[1].Enable := FALSE;
			END_IF
				
		(* Case 10 *)	
		10:	(* Check Modules Error *)
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
					WorkFlow[1].Enable := FALSE;
			ELSIF (CmdExe.PhaseStopRequest > 0 AND 
					((Mission^.State = MISSION_STATE_NOP AND (InWaitPosition OR (Ciclo_Deposito_Lastra_Depal.Passo = 56 AND Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO))) OR
						(Mission^.State = MISSION_STATE_DEPOSITO_LASTRA_DEPAL_RUN AND (Ciclo_Deposito_Lastra_Depal.Passo = 56 AND Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO)))) THEN
					CmdExe.PhaseStopRequest :=1;
					TFWorkFlowCase(ADR(WorkFlow[1]),100,WorkflowCase_JMP);	
			ELSE
				TFTimerCall(ADR(TimerPacchi1Minuto),Cfg.TimeBase);
				TFTimerSet(ADR(TimerPacchi1Minuto),60000,NOT AttivaTimerContaPacchi1Minuto);
				TFTimerCall(ADR(TimerPacchi5Minuti),Cfg.TimeBase);
				TFTimerSet(ADR(TimerPacchi5Minuti),300000,NOT AttivaTimerContaPacchi5Minuti);
				IF TFTimerDone(ADR(TimerPacchi1Minuto)) THEN
					TimerDone1 := TimerDone1 +1;
					AttivaTimerContaPacchi1Minuto := FALSE;
					PacchiPrelevatiAlMinuto := Pacchi1Minuto;
					PacchiAlMinuto[TimerDone1] := PacchiPrelevatiAlMinuto;	
					Pacchi1Minuto := 0;					
				END_IF
				IF TFTimerDone(ADR(TimerPacchi5Minuti)) THEN
					AttivaTimerContaPacchi5Minuti := FALSE;
					PacchiPrelevatiIn5MinutiAppoggio := 0;
					FOR cuontpac := 1 TO TimerDone1 DO
						PacchiPrelevatiIn5MinutiAppoggio := PacchiPrelevatiIn5MinutiAppoggio + PacchiAlMinuto[cuontpac];
						PacchiAlMinuto[cuontpac] := 0;
					END_FOR	
					IF TimerDone1 > 0 AND PacchiPrelevatiIn5MinutiAppoggio > 0 THEN
						PacchiPrelevatiIn5Minuti := PacchiPrelevatiIn5MinutiAppoggio / TimerDone1;
						TimerDone1 := 0;
					END_IF		
				END_IF
				(* Filtro fotocellula presenza materiale su pinza *)
				(*Filtro_PX_GripPresence(IN_Signal := PX_GripPresence,
										FilterTime_ON := 400,
										FilterTime_OFF := 500,
										OUT_Signal_Filtrato => PX_GripPresenceFiltrata);
				//*)
				//PX_GripPresenceFiltrata := PX_GripPresence;
				PX_GripPresenceFiltrata := Modules^.Pinza.StatoPinza.ElementoPrelevato;
				(* Stato delle piazzole: valuto se sono tutte occupate in modo da segnalarlo all'operatore mediante lampeggio *)
				//AllWABusy := TFCheckPalletFull(WorkArea,WorkAreaState,WorkPickPointState); 
				
				(* Controllo se nella postazione pallet e falde è presente il materiale *)	
				PalletStackEmpty := 0;// TFCheckPalletPresence(WorkArea,WorkAreaState,IN.PX_WorkArea);
				LayerStackEmpty := 0;//NOT IN.PX_WorkArea[NumPostazioneFALDE];  TFCheckLayerPresence(WorkArea,WorkAreaState,IN.PX_WorkArea);
				//IF LayerStackEmpty > 0 OR (IN.PX_WorkArea[NumPostazioneFALDE] AND WorkAreaManager^.State = WAMANAGER_NOP)THEN
				//	CmdExe.RapidStopRequest := 1;
				//	TFError(ErrMODULEPALLETIZERROBOT_EMPTYLAYERSTACK,PalletLayerPresence,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				//END_IF
				
				(* Set della richiesta della posizione di  riposo da inviare al WAM *)		
				WaitPositionRequest := (WaitPositionRequest OR ExternalWaitPositionRequest OR CmdExe.PhaseStopRequest > 0);
				

				
				TFCalcoliFuoriIngombri.StatoWAM_precedente := WorkAreaManager^.State;//Setto lo stato del wam prima che venga elaborato il FB
				
				(* Chiamata del FB che gestisce il Pallettizzatore osservendo lo stato delle varie Work Area e del Pallettizatore stesso *)		
				TFPalletizerWorkAreaManagerTF(	Cfg 			:= Cfg,
												WorkArea 		:= WorkArea,
												WorkAreaState 	:= WorkAreaState,
												WorkAreaOffset	:= WorkAreaOffset,
												PX_WorkArea 	:= IN.PX_WorkArea,
												WorkPickPoint 	:= WorkPickPoint,
												WorkPickPointState := WorkPickPointState,
												WorkAreaProductionList := WorkAreaProductionList,
												//WorkPickPointStoreState:= WorkPickPointStoreState,
												//WorkPickPointTransportState := WorkPickPointTransportState,
												WorkPickPointOffset := WorkPickPointOffset,
												Forming 		:= Forming,
												Pallet 			:= Pallet,
												Layer 			:= Layer,
												Mission 		:= Mission,
												PickPlaceParameters 		:= PickPlaceParameters,
												ExternalWaitPositionRequest := WaitPositionRequest,
												ProgressiveNrWA 		:= ProgressiveNrWA,
												UsedCode				:= UsedCode,
												TCPParameter 			:= TCPParameter,
												TilterPack 				:= TilterPack,
												PreviousPWA 			:= PreviousPWA,
												RestoreCWA 				:= RestoreCWA,
												PreviousStackWA 		:= PreviousStackWA,
												WorkAreaManager 		:= WorkAreaManager,
												ModuleAX_X 				:= ADR(Modules^.AX_X),
												ModuleAX_Y 				:= ADR(Modules^.AX_Y),
												ModuleAX_Z 				:= ADR(Modules^.AX_Z),
												ModuleAX_J 				:= ADR(Modules^.AX_J),
												ModulePinza           	:= ADR(Modules^.Pinza),
												WorkAreaZone			:= WorkAreaZone,
												GestioneAZoneAbilitata 	:= GestioneAZoneAbilitata, 
												//HandlingPackTable 		:= HandlingPackTable,
												ArrayPacchi				:= ArrayPacchi,
												HandlingRun				:= IN.HandlingRun,
												//RichiestaStartRibaltino := RichiestaStartRibaltino,
												AbilitaForzaturaStatoDaRiposoAPrelievo 			:= AbilitaForzaturaStatoWAMDaCicloRiposoACicloPrelievo,
												AbilitaDisposizionePalletContinua 				:= AbilitaDisposizionePalletContinua,
												AbilitaDepositoPaccoOrrizzonataleConTasteggio 	:= AbilitaDepositoPaccoOrrizzonataleConTasteggio,
												AbilitaOffsetInUscitaTasteggioPrelievoPallet 	:= AbilitaOffsetInUscitaTasteggioPrelievoPallet,
												RichiestaIngZonaDX 								:= RichiestaIngZonaDX, 
												RichiestaIngZonaSX 								:= RichiestaIngZonaSX,
												InWaitPosition									=> InWaitPosition,
												DepositoPaccoInLenta							=> DepositoPaccoInLenta,
												ForzaPrelievoPaccoDuranteCicloDiRiposo 			=> ForzaPrelievoPaccoDuranteCicloDiRiposo,);

				(* Valuto se il WAMANAGER ha un errore, in tal caso blocco tutto *)								
				IF TFPalletizerWorkAreaManagerTF.Errore.Code > 0 THEN
					CmdExe.PhaseStopRequest := 1;
					WorkFlow[1].Enable := FALSE;
					TFError(TFPalletizerWorkAreaManagerTF.Errore.Code,TFPalletizerWorkAreaManagerTF.Errore.ExtraCode,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				END_IF

				(* Chiamata della Function che assegna le volocità ai vari assi *)	
				IF (NOT AssiInterpolati	AND AbilitaInterpolazioneAssi^) OR NOT AbilitaInterpolazioneAssi^ THEN					
					TFCalcoloVelocita(AxisOverride := AxisOverride, 
													Mission := Mission,
													ArrayPacchi		 := ArrayPacchi,
													DepositoPaccoInLenta := DepositoPaccoInLenta);
				END_IF
				
				//#################################################################################################
				//#################################################################################################
				(* Chiamata della FB che definisce le quote necessarie a compiere la traiettoria della missione in corso *)
				TFCalcoloTraiettoria(	Traiettoria := Traiettoria,
										WorkSpace := WorkSpace,
										WorkFootprint := WorkFootprint,
										WorkPickPoint := WorkPickPoint,
										WorkAreaState := WorkAreaState,
										WorkPickPoint := WorkPickPoint,
										WorkPickPointState := WorkPickPointState,
										WorkPickPointDimension := WorkPickPointDimension,
										WorkArea := WorkArea,
										Pallet := Pallet,
										Layer := Layer,
										Forming := Forming,
										Mission := Mission,
										WorkAreaManager := WorkAreaManager,
										ModuleAX_X := ADR(Modules^.AX_X),
										ModuleAX_Y := ADR(Modules^.AX_Y),
										ModuleAX_Z := ADR(Modules^.AX_Z),
										ModuleAX_J := ADR(Modules^.AX_J));
				(* Calcolo dell'ingombro delle colonne centrali*)						
				TFCalcoliFuoriIngombri(  Traiettoria := Traiettoria,
										WorkSpace := WorkSpace,
										WorkFootprint := WorkFootprint,
										WorkPickPoint := WorkPickPoint,
										//WorkPickPointState := WorkPickPointState,
										WorkPickPointDimension := WorkPickPointDimension,
										WorkArea := WorkArea,
										WorkAreaState := WorkAreaState,
										WorkAreaOffset:= WorkAreaOffset,
										Pallet := Pallet,
										Layer := Layer,
										Forming := Forming,
										PickPlaceParameters:=PickPlaceParameters,
										Mission := Mission,
										WorkAreaManager := WorkAreaManager,
										ModuleAX_X := ADR(Modules^.AX_X),
										ModuleAX_Y := ADR(Modules^.AX_Y),
										ModuleAX_Z := ADR(Modules^.AX_Z),
										ModuleAX_J := ADR(Modules^.AX_J),
										PX_WorkArea 	:= IN.PX_WorkArea,
										AbilitaCalcoloIngombroOttimizzato := AbilitaCalcoloIngombroOttimizzato^);						
					



				(* Reset delle momorie di quota raggiunta(per sicurezza..)*)						
				QuotaAnticipoDinamicaX_Raggiunta := FALSE; 
				QuotaAnticipoDinamicaY_Raggiunta := FALSE; 
				QuotaAnticipoDinamicaZ_Raggiunta := FALSE; 
				QuotaAnticipoDinamicaJ_Raggiunta := FALSE;
				(* Calcolo delle quote di anticipo *)
				(*TFCalcoloPuntiDiAnticipoDinamici(	Traiettoria := Traiettoria,
													WorkSpace := WorkSpace,
													WorkFootprint := WorkFootprint,
													WorkPickPoint := WorkPickPoint,
													WorkPickPointState := WorkPickPointState,
													WorkPickPointOffset := WorkPickPointOffset,
													WorkPickPointDimension := WorkPickPointDimension,
													WorkArea := WorkArea,
													WorkAreaState := WorkAreaState,
													Pallet := Pallet,
													Layer := Layer,
													Forming := Forming,
													PickPlaceParameters:=PickPlaceParameters,
													Mission := Mission,
													WorkAreaManager := WorkAreaManager,
													ModuleAX_X := ADR(Modules^.AX_X),
													ModuleAX_Y := ADR(Modules^.AX_Y),
													ModuleAX_Z := ADR(Modules^.AX_Z),
													ModuleAX_J := ADR(Modules^.AX_J),
													AbilitaAnticipoDinamico := AbilitaAnticipoDinamico^);*)
												
				(* Valutazione se gli assi sono in finestra di PassMode *) 
				TFValutaAssiInFinestraDiPassMode(	ModuleAX_X := ADR(Modules^.AX_X),
													ModuleAX_Y := ADR(Modules^.AX_Y),
													ModuleAX_Z := ADR(Modules^.AX_Z),
													ModuleAX_J := ADR(Modules^.AX_J),
													WorkAreaManager := WorkAreaManager,
													Traiettoria := Traiettoria);
									
				(* Chiamata della function che controlla che i valori assunti dalle quote non vadano fuori dai limiti e non vi sia collisione tra pinza e oggetti *)						
				
				IF WorkAreaManager^.State <> WAMANAGER_NOP AND WorkAreaManager^.State <> WAMANAGER_CICLO_RIPOSO_INIT AND WorkAreaManager^.State <> WAMANAGER_CICLO_LASTRA_PP_INIT THEN
					ErroreDiInterferenza := TFControlloInterferenza( Traiettoria := Traiettoria,
											WorkSpace := WorkSpace,
											WorkFootprint := WorkFootprint,
											WorkPickPoint := WorkPickPoint,
											WorkArea := WorkArea,
											Pallet := Pallet,
											Layer := Layer,
											Forming := Forming,
											Mission := Mission,
											WorkAreaManager := WorkAreaManager,
											ModuleAX_X := ADR(Modules^.AX_X),
											ModuleAX_Y := ADR(Modules^.AX_Y),
											ModuleAX_Z := ADR(Modules^.AX_Z),
											ModuleAX_J := ADR(Modules^.AX_J));	
				END_IF
				(* Controllo che non sia settata la memoria di Errore Di Interferenza *)							
				IF ErroreDiInterferenza > 0 THEN
					TFError(ErroreDiInterferenza,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					CmdExe.RapidStopRequest := 1;
				ELSIF TFCalcoliFuoriIngombri.Errore > 0 THEN
					TFError(TFCalcoliFuoriIngombri.Errore,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
					CmdExe.RapidStopRequest := 1;
				END_IF
								
				(* Verifico se la pinza se è in quota di fuori-Ingombro e setto un bit *)
				PinzaInQuotaFuoriIngombro := TFFuoriIngombroVerticaleOK(Modules^.AX_Z.Ax^.AxRef^.NcToPlc.SetPos,Mission);
				(* Se la quota dell'asse Z è inferiore alla quaota di deposito + 100 mm, disabilito il controllo.
					In questo modo non ho falsi errori in fase di deposito *)
				AbilitaControlloPHGripPresence := AbilitaControlloPHGripPresence AND PinzaInQuotaFuoriIngombro;//Modules^.AX_Z.Ax^.AxRef^.NcToPlc.SetPos >= Mission^.ZPlace + 100;	
	
				PinzaConProdottoInPresa := Modules^.Pinza.StatoPinza.LatoDxPiastrellaInPresa AND Modules^.Pinza.StatoPinza.LatoSxPiastrellaInPresa OR ProductOnGripper <> KNOPRODUCT;

				(* Set Stato Missione in base allo stato del Work Area Manager*)
				CASE WorkAreaManager^.State OF					
					WAMANAGER_NOP:
						//WorkPickPointState^[Mission^.PPick].TC := 0;
						//DepositoFaldaSuCatastaVuoti := FALSE;
						Mission^.State := MISSION_STATE_NOP;
						MissionStateCase^.NCase := 0;
						MissionStateCase^.Mission := MISSION_STATE_NOP;

						//ResetComandoRibaltinoEseguito := FALSE;
						
						(* Verifica che vi siano falda e pallet con codice uguali a quello delle foratura attiva *)
						//PalletLayerPresence := TFPalletizerCheckPalletLayerCode(WorkArea,WorkAreaState,Forming);
						//IF PalletLayerPresence > 0 THEN
						//	CmdExe.PhaseStopRequest := 1;
						//	WorkFlow[1].Enable := FALSE;
						//	TFError(PalletLayerPresence,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						//END_IF
						
						IF Modules^.AX_Z.Ax^.Status.ActPosition >= QuotaFuoriIngombro_Z_AVUOTO - 5 OR Modules^.AX_Z.Ax^.Status.ActPosition >= QuotaFuoriIngombro_Z_ConPEZZO - 5 THEN
							PinzaInQuotaFuoriIngombroPerTrasporti := TRUE;
						//ELSE
						//	PinzaInQuotaFuoriIngombroPerTrasporti := FALSE;
						END_IF
					{Region "WA MANAGER RIPOSO"}													
					WAMANAGER_CICLO_RIPOSO_RUN:
						(* Controllo che la pinza si libera *)
						IF AbilitaControlloPHGripPresence THEN
							IF PinzaConProdottoInPresa THEN
								CmdExe.RapidStopRequest := 1;
								TFError(ErrPRESENZA_MATERIALE_SUPINZA_CICLO_RIPOSO,ErrNull,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
							ELSE
								Mission^.State := MISSION_STATE_VAIaRIPOSO_RUN;
							END_IF
						ELSE
							PX_GripPresenceOK := TRUE;
							Mission^.State := MISSION_STATE_VAIaRIPOSO_RUN;
						END_IF
						(* Quando Sono Fuori ingombro setto il FI x il ribaltino *)
						IF (Modules^.AX_Z.Ax^.Status.ActPosition >= QuotaFuoriIngombro_Z_AVUOTO - 5 OR Modules^.AX_Z.Ax^.Status.ActPosition >= QuotaFuoriIngombro_Z_ConPEZZO - 5) AND
							 NOT ResetComandoRibaltinoEseguito THEN
								PinzaInQuotaFuoriIngombroPerTrasporti := TRUE;
								ResetComandoRibaltinoEseguito := TRUE;
						END_IF
																				
					WAMANAGER_CICLO_RIPOSO_END:
						PX_GripPresenceOK := FALSE;
						Mission^.State := MISSION_STATE_NOP;
						ProductOnGripper := KNOPRODUCT;
					{endregion}
					{Region "WA MANAGER FALDA"}
					WAMANAGER_CICLO_PRELIEVO_FALDA_RUN:
						OUT.StartTilter := FALSE;
						//DepositoFaldaSuCatastaVuoti := TRUE;
						Modules^.AX_Z.AbilitaOffsetInUscitaTasteggio := FALSE;
						
						IF AbilitaControlloPHGripPresence THEN
							IF (PX_GripPresenceFiltrata AND NOT PX_GripPresenceOK) AND PinzaInQuotaFuoriIngombro THEN
								TFError(ErrPRESENZA_MATERIALE_SUPINZA_CICLO_PRELFALDA,ErrPRESENZA_MATERIALE_SUPINZA_CICLO_PRELFALDA,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
								CmdExe.RapidStopRequest := 1;
							ELSE
								PX_GripPresenceOK := TRUE;
								Mission^.State := MISSION_STATE_PRELIEVO_FALDA_RUN;
							END_IF
						ELSE
							PX_GripPresenceOK := TRUE;
							Mission^.State := MISSION_STATE_PRELIEVO_FALDA_RUN;
						END_IF
												
					WAMANAGER_CICLO_PRELIEVO_FALDA_END:
						OUT.StartTilter := FALSE;
						PX_GripPresenceOK := FALSE;
						//DepositoFaldaSuCatastaVuoti := FALSE;
						Mission^.State := MISSION_STATE_DEPOSITO_FALDA_RUN;
						ProductOnGripper := KPRODUCTLOADED;
				   							
					WAMANAGER_CICLO_DEPOSITO_FALDA_RUN:
						OUT.StartTilter := FALSE;
						//DepositoFaldaSuCatastaVuoti := FALSE;
						Modules^.AX_Z.AbilitaOffsetInUscitaTasteggio := FALSE;
						
						(* Se è abilitato il controllo della presenza utilizzando la fotocellula *)
						IF AbilitaControlloPHGripPresence THEN
							(* Se NON vedo la fotocellula e ho memorizzato di avere un prodotto *)
							IF not PX_GripPresenceFiltrata AND ProductOnGripper = KPRODUCTLOADED THEN
								TFError(ErrLOADLOST,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
								CmdExe.RapidStopRequest := 1;
							END_IF
						END_IF	
						
						(* Se non ho rilevato alcun errore procedo con la missione *)
						IF CmdExe.RapidStopRequest <> 1 THEN
								Mission^.State := MISSION_STATE_DEPOSITO_FALDA_RUN;
						END_IF
					
					WAMANAGER_CICLO_DEPOSITO_FALDA_END:
						OUT.StartTilter := FALSE;
						ProductOnGripper := KNOPRODUCT;
					{endregion}		

					{Region "WA MANAGER LASTRA DA PICKPOINT"}
					(* Ciclo lastra PRELIEVO lastra da punto di prelievo classico *)	
					WAMANAGER_CICLO_PRELIEVO_LASTRA_PP_RUN:
						(* Controllo che la pinza si libera *)
						IF PinzaConProdottoInPresa AND PinzaInQuotaFuoriIngombro THEN
							CmdExe.RapidStopRequest := 1;
							TFError(ErrPRESENZA_MATERIALE_SUPINZA_CICLO_PRELPACCO,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						ELSE					
							Mission^.State :=  MISSION_STATE_PRELIEVO_LASTRA_PP_RUN;
						END_IF
							 
					WAMANAGER_CICLO_PRELIEVO_LASTRA_PP_END:;
						 
					(* Ciclo lastra deposito su rulliera *)
					WAMANAGER_CICLO_DEPOSITO_LASTRA_PP_RUN:
						(* Se ho presenza logica *)
						IF ProductOnGripper = KPRODUCTLOADED THEN
							(* Se è abilitato il controllo della presenza utilizzando la fotocellula *)
							IF AbilitaControlloPHGripPresence THEN
								(* Se NON vedo la fotocellula *)
								IF NOT PinzaConProdottoInPresa AND PinzaInQuotaFuoriIngombro THEN
									TFError(ErrLOADLOST,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									CmdExe.RapidStopRequest := 1;
									CmdExe.PhaseStopRequest := 1;
								END_IF
							END_IF
						END_IF		
							
						(* Controllo la presenza del pallet nella Postazione di deposito *)	
						IF (Mission^.TPick = TPICK_LASTRA AND NOT IN.PX_WorkArea[Mission^.PPlace]) AND NOT SimulazioneSenzaPalletFalde THEN
							CmdExe.PhaseStopRequest := 1;
							TFError(ErrPALLETNOTPRESENT,Mission^.PPlace,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						(* Se non ho alcun errore procedo con la missione *)
						ELSIF CmdExe.RapidStopRequest = 0 THEN
							Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_PP_RUN;
						END_IF	
						 
					WAMANAGER_CICLO_DEPOSITO_LASTRA_PP_END:
						 ProductOnGripper := KNOPRODUCT;
				
					{endregion}

					{Region "WA MANAGER LASTRA WA PAL"}		
					WAMANAGER_CICLO_PRELIEVO_LASTRA_WA_RUN:
						(* Controllo che la pinza si libera *)
						IF ((PX_GripPresenceFiltrata AND NOT PX_GripPresenceOK AND AbilitaControlloPHGripPresence) (*OR ProductOnGripper <> KNOPRODUCT*)) AND PinzaInQuotaFuoriIngombro THEN
							CmdExe.RapidStopRequest := 1;
							TFError(ErrPRESENZA_MATERIALE_SUPINZA_CICLO_PRELPACCO,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						ELSE					
							Mission^.State :=  MISSION_STATE_PRELIEVO_LASTRA_WA_RUN;	
							PX_GripPresenceOK := TRUE;		
						END_IF					
					WAMANAGER_CICLO_PRELIEVO_LASTRA_WA_END:
						PX_GripPresenceOK := FALSE;
						ProductOnGripper := KPRODUCTLOADED;												
						
					WAMANAGER_CICLO_DEPOSITO_LASTRA_WA_RUN:
						(* Se ho presenza logica *)
						IF ProductOnGripper = KPRODUCTLOADED THEN
							(* Se è abilitato il controllo della presenza utilizzando la fotocellula *)
							IF AbilitaControlloPHGripPresence THEN
								(* Se NON vedo la fotocellula *)
								IF NOT PX_GripPresenceFiltrata AND PinzaInQuotaFuoriIngombro THEN
									TFError(ErrLOADLOST,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									CmdExe.RapidStopRequest := 1;
									CmdExe.PhaseStopRequest := 1;
								END_IF
							END_IF
						END_IF		
							
						(* Controllo la presenza del pallet nella Postazione di deposito *)	
						IF (Mission^.TPick = TPICK_PACK AND NOT IN.PX_WorkArea[Mission^.PPlace]) AND NOT SimulazioneSenzaPalletFalde THEN
							CmdExe.PhaseStopRequest := 1;
							TFError(ErrPALLETNOTPRESENT,Mission^.PPlace,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						(* Se non ho alcun errore procedo con la missione *)
						ELSIF CmdExe.RapidStopRequest = 0 THEN
							Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_WA_RUN;
						END_IF	
						
					WAMANAGER_CICLO_DEPOSITO_LASTRA_WA_END:
						ProductOnGripper := KNOPRODUCT;
					{endregion}	
{region "DEPALLETTIZZATORE"}	
					(* Ciclo lastra PRELIEVO lastra depallettizzatore *)	
					WAMANAGER_CICLO_PRELIEVO_LASTRA_DEPAL_RUN:
						(* Controllo che la pinza si libera *)
						IF ((PX_GripPresenceFiltrata AND NOT PX_GripPresenceOK AND AbilitaControlloPHGripPresence) OR ProductOnGripper <> KNOPRODUCT) AND PinzaInQuotaFuoriIngombro THEN
							CmdExe.RapidStopRequest := 1;
							TFError(ErrPRESENZA_MATERIALE_SUPINZA_CICLO_PRELPACCO,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						ELSE					
							Mission^.State :=  MISSION_STATE_PRELIEVO_LASTRA_DEPAL_RUN;	
							PX_GripPresenceOK := TRUE;		
						END_IF
							 
					WAMANAGER_CICLO_PRELIEVO_LASTRA_DEPAL_END:;
						 
					(* Ciclo lastra deposito su rulliera *)
					WAMANAGER_CICLO_DEPOSITO_LASTRA_DEPAL_RUN:
						(* Se ho presenza logica *)
						IF ProductOnGripper = KPRODUCTLOADED THEN
							(* Se è abilitato il controllo della presenza utilizzando la fotocellula *)
							IF AbilitaControlloPHGripPresence THEN
								(* Se NON vedo la fotocellula *)
								IF NOT PX_GripPresenceFiltrata AND PinzaInQuotaFuoriIngombro THEN
									TFError(ErrLOADLOST,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									CmdExe.RapidStopRequest := 1;
									CmdExe.PhaseStopRequest := 1;
								END_IF
							END_IF
						END_IF		
							
						(* Controllo la presenza del pallet nella Postazione di deposito *)	
						IF (Mission^.TPick = TPICK_PACK AND NOT IN.PX_WorkArea[Mission^.PPlace]) AND NOT SimulazioneSenzaPalletFalde THEN
							CmdExe.PhaseStopRequest := 1;
							TFError(ErrPALLETNOTPRESENT,Mission^.PPlace,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
						(* Se non ho alcun errore procedo con la missione *)
						ELSIF CmdExe.RapidStopRequest = 0 THEN
							Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_DEPAL_RUN;
						END_IF	
						 
					WAMANAGER_CICLO_DEPOSITO_LASTRA_DEPAL_END:
						 ProductOnGripper := KNOPRODUCT;
							  
					(* Ciclo deposito FALDA su magazzino dedicato dopo prelievo misto da postazione *)
					WAMANAGER_CICLO_DEPOSITO_FALDA_DEPAL_RUN:
						 	
						(* Se ho presenza logica *)
						(*IF ProductOnGripper = KPRODUCTLOADED THEN
							(* Se è abilitato il controllo della presenza utilizzando la fotocellula *)
							IF AbilitaControlloPHGripPresence THEN
								(* Se NON vedo la fotocellula *)
								IF NOT PX_GripPresenceFiltrata AND PinzaInQuotaFuoriIngombro THEN
									TFError(ErrLOADLOST,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									CmdExe.RapidStopRequest := 1;
									CmdExe.PhaseStopRequest := 1;
								END_IF
							END_IF
						END_IF*)
							
						IF CmdExe.RapidStopRequest = 0 THEN
							Mission^.State := MISSION_STATE_DEPOSITO_FALDA_DEPAL_RUN;
						END_IF		 
														 
					WAMANAGER_CICLO_DEPOSITO_FALDA_DEPAL_END:
						ProductOnGripper := KNOPRODUCT;	
{endregion}													
				END_CASE
				
{region "CASE MISSION"}		
				(* Eseguo il passo della Missione *)
				CASE Mission^.State OF					
					MISSION_STATE_NOP:
						(* Missione di NOP - WorkFlow  *)
						IF MissionStateCase^.Mission <> MISSION_STATE_NOP THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_NOP;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - *)
							0:	
								MissionStateCase^.NCase := 0;
						END_CASE
												
					MISSION_STATE_INIT:
						(* Missione di INIT - WorkFlow  *)
						IF MissionStateCase^.Mission <> MISSION_STATE_INIT THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_INIT;
						END_IF
				{Region "MISSION RIPOSO"}						
					MISSION_STATE_VAIaRIPOSO_RUN:// Assegnato al WorkFlow 2
						(* Missione di RIPOSO - WorkFlow  *)
						NumeroWF := 2;//Numero del WorkFlow
						IF ((MissionStateCase^.Mission <> MISSION_STATE_VAIaRIPOSO_RUN AND MissionStateCase^.Mission <> MISSION_STATE_VAIaRIPOSO_END) AND NOT ForzaPrelievoPaccoDuranteCicloDiRiposo)  THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_VAIaRIPOSO_RUN;
						ELSIF ForzaPrelievoPaccoDuranteCicloDiRiposo THEN
							WorkFlow[NumeroWF].Enable := FALSE;
							MissionStateCase^.NCase := 10;
							Ciclo_Di_Riposo.Stato := INTERROTTO;
						END_IF	
												
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF	
							
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_VAIaRIPOSO_END;
						END_CASE							 
					MISSION_STATE_VAIaRIPOSO_END:
						(* Missione di RIPOSO TERMINATA - WorkFlow  *)
						IF MissionStateCase^.Mission <> MISSION_STATE_VAIaRIPOSO_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_VAIaRIPOSO_END;
						END_IF	
				{ENDREGION}																		
				{Region "MISSION FALDA"}
					MISSION_STATE_PRELIEVO_FALDA_RUN:// Assegnato al WorkFlow 3
						(* Missione di prelievo falda- WorkFlow  *)
						NumeroWF := 3;//Numero del WorkFlow
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_FALDA_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_FALDA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_FALDA_RUN;
						END_IF
																
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
								WorkFlow[NumeroWF].Enable := FALSE;
								IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
									IF Warning.Code <> ErrNULL THEN
										TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									ELSE
										TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									END_IF
								ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
									MissionStateCase^.NCase := 10;
								ELSE
									(*Invio comando di stop ai moduli*)
									TFParametersArrayClear(ADR (ParametersArray));
									TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
									MissionStateCase^.NCase := 0;
									IF TFIsModuleWarning(Warning) THEN
										TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
									END_IF
								END_IF
							END_IF
							
							(* Case finale *)
							10:	
								Mission^.State := MISSION_STATE_PRELIEVO_FALDA_END;
								
						END_CASE
						
					MISSION_STATE_PRELIEVO_FALDA_END:
						(* Missione TERMINATA - WorkFlow  *)
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_FALDA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_FALDA_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_PRELIEVO_FALDA_END;
								MissionStateCase^.NCase := 0;
						END_CASE	
					
					MISSION_STATE_DEPOSITO_FALDA_RUN: // Assegnato al WorkFlow 4
						NumeroWF:=4;//Numero del WorkFlow
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_FALDA_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_FALDA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_FALDA_RUN;
						END_IF
						
						CASE MissionStateCase^.NCase OF
						(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_DEPOSITO_FALDA_END;
								
						END_CASE
						
					MISSION_STATE_DEPOSITO_FALDA_END:					
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_FALDA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_FALDA_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_DEPOSITO_FALDA_END;
								MissionStateCase^.NCase := 0;
						END_CASE	
				{ENDREGION}																		
				{Region "MISSION LASTRA DA PICKPOINT"}
				MISSION_STATE_PRELIEVO_LASTRA_PP_RUN:
						NumeroWF:= 5  ;//Numero del WorkFlow				
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_PP_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_PP_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_PP_RUN;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_PP_END;
									
						END_CASE				
					MISSION_STATE_PRELIEVO_LASTRA_PP_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_PP_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_PP_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_PP_END;
							
						END_CASE					
					MISSION_STATE_DEPOSITO_LASTRA_PP_RUN:
						NumeroWF:= 6;//Numero del WorkFlow				
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_PP_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_PP_RUN THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_PP_RUN;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									//IF (Ciclo_Deposito_Lastra_Depal.Passo = 56 AND Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO) OR StopDepositoPerArresto THEN
									//	WorkFlow[NumeroWF].Enable := TRUE;
									//ELSE
										WorkFlow[NumeroWF].Enable := FALSE;
									//END_IF
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN//AND NOT StopDepositoPerArresto THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_PP_END;
									
						END_CASE					
					MISSION_STATE_DEPOSITO_LASTRA_PP_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_PP_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_PP_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_PP_END;
							
						END_CASE

				{endregion}

				{Region "MISSION LASTRA WA"}
					MISSION_STATE_PRELIEVO_LASTRA_WA_RUN:// Assegnato al WorkFlow 7
						NumeroWF:=7;//Numero del WorkFlow
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_WA_RUN AND MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_WA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_WA_RUN;
						END_IF
	 					//
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;			
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;			
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_WA_END;							
						END_CASE
						
					MISSION_STATE_PRELIEVO_LASTRA_WA_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_WA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_WA_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_WA_END;
								MissionStateCase^.NCase := 0;
													
						END_CASE		
				{ENDREGION}																		
				{Region "MISSION LASTRA PAREGGIATORE"}
					MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_RUN:// Assegnato al WorkFlow 6
						NumeroWF:=8;//Numero del WorkFlow
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_RUN AND MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_RUN;
						END_IF
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_END;
						END_CASE
							 
					MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_SU_PAREGGIATORE_END;
								MissionStateCase^.NCase := 0;
						END_CASE
						
					MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_RUN:// Assegnato al WorkFlow 7
						NumeroWF:=7;//Numero del WorkFlow
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_RUN AND MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_WA_RUN;
						END_IF			
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_WA_END;
						END_CASE
					MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_DA_PAREGGIATORE_END;
								MissionStateCase^.NCase := 0;
						END_CASE
				{ENDREGION}																		
				{Region "MISSION DEPOSITO LASTRA WA"}											
					MISSION_STATE_DEPOSITO_LASTRA_WA_RUN:// Assegnato al WorkFlow 
						NumeroWF:=9;//Numero del WorkFlow				
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_WA_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_WA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_WA_RUN;
						END_IF
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_WA_END;
						END_CASE
						
					MISSION_STATE_DEPOSITO_LASTRA_WA_END:	
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_WA_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_WA_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_WA_END;
							
						END_CASE
					{ENDREGION}																		
																		
				{Region "MISSION DEPAL"}			
					MISSION_STATE_PRELIEVO_LASTRA_DEPAL_RUN:
						NumeroWF:=10;//Numero del WorkFlow				
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_DEPAL_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_DEPAL_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_DEPAL_RUN;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_DEPAL_END;
									
						END_CASE				
					MISSION_STATE_PRELIEVO_LASTRA_DEPAL_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_PRELIEVO_LASTRA_DEPAL_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_PRELIEVO_LASTRA_DEPAL_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_PRELIEVO_LASTRA_DEPAL_END;
							
						END_CASE					
					MISSION_STATE_DEPOSITO_LASTRA_DEPAL_RUN:
						NumeroWF:=12;//Numero del WorkFlow				
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_DEPAL_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_DEPAL_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_DEPAL_RUN;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									IF (Ciclo_Deposito_Lastra_Depal.Passo = 56 AND Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO) OR StopDepositoPerArresto THEN
										WorkFlow[NumeroWF].Enable := TRUE;
									ELSE
										WorkFlow[NumeroWF].Enable := FALSE;
									END_IF
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END AND NOT StopDepositoPerArresto THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_DEPAL_END;
									
						END_CASE					
					MISSION_STATE_DEPOSITO_LASTRA_DEPAL_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_LASTRA_DEPAL_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_LASTRA_DEPAL_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_DEPOSITO_LASTRA_DEPAL_END;
							
						END_CASE
					MISSION_STATE_DEPOSITO_FALDA_DEPAL_RUN:
						NumeroWF:=11;//Numero del WorkFlow				
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_FALDA_DEPAL_RUN  AND MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_FALDA_DEPAL_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_FALDA_DEPAL_RUN;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							(* Case 0 - Attivazione e inizializzazione del Workflow*)
							0:	WorkFlow[NumeroWF].Enable := TRUE;
								TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
								MissionStateCase^.NCase := 1;
				
							(* Case 1 - Attesa di un eventuale stop rapido/stop in fase o attesa del completamento/errore workflow *)
							1:	IF CmdExe.RapidStopRequest > 0 OR
									(NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									MissionStateCase^.NCase := 2;
								END_IF;
				
							(* Case 2 - Wait WF End *)
							2: IF (NOT WorkFlow[NumeroWF].Enable OR WorkFlow[NumeroWF].State = StateWF_END OR WorkFlow[NumeroWF].WFCase = StateWF_ERROR) THEN
									WorkFlow[NumeroWF].Enable := FALSE;
									IF WorkFlow[NumeroWF].WFCase = StateWF_ERROR THEN
										IF Warning.Code <> ErrNULL THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										ELSE
											TFError(ErrWF,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									ELSIF WorkFlow[NumeroWF].State = StateWF_END THEN
										MissionStateCase^.NCase := 10;
									ELSE
										(*Invio comando di stop ai moduli*)
										TFParametersArrayClear(ADR (ParametersArray));
										TFPalletizerModulesCommandSend(CmdSTOP,ParametersArray,Modules);
										MissionStateCase^.NCase := 0;
										IF TFIsModuleWarning(Warning) THEN
											TFError(Warning.Code,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
										END_IF
									END_IF
								END_IF
								
							(* Case finale *)
							10:
								Mission^.State := MISSION_STATE_DEPOSITO_FALDA_DEPAL_END;
									
						END_CASE					
					MISSION_STATE_DEPOSITO_FALDA_DEPAL_END:
						IF MissionStateCase^.Mission <> MISSION_STATE_DEPOSITO_FALDA_DEPAL_END THEN
							MissionStateCase^.NCase := 0;
							MissionStateCase^.Mission := MISSION_STATE_DEPOSITO_FALDA_DEPAL_END;
						END_IF
						
						CASE MissionStateCase^.NCase OF
							
							(* Case 0 - *)
							0:  Mission^.State := MISSION_STATE_DEPOSITO_FALDA_DEPAL_END;
							
						END_CASE
				{ENDREGION}													  

					MISSION_STATE_ERROR:
						CmdExe.PhaseStopRequest := 1;
						WorkFlow[1].Enable := FALSE;
						
				ELSE;
				END_CASE
			END_IF
			
		(* Case 100 *)
		(* WorkFlow END *)
		100:WorkFlow[1].State := StateWF_END;
			WorkFlow[1].Enable := FALSE;
			TFWorkFlowCase(ADR(WorkFlow[1]),0,WorkflowCase_JMP);
			
		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[1]),ADR(WorkFlowErrorLog[1]));
			WorkFlow[1].Enable := FALSE;

		ELSE
			TFWorkFlowError(ADR(WorkFlow[1]),ADR(WorkFlowErrorLog[1]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));

	END_CASE;

END_IF 
{endregion}	
	 
{region "WorkFlow 2 -  CICLO DI RIPOSO"}
WF02_CicloDiRiposo();
{endregion}	 

{region "WorkFlow 3 -  CICLO PRELIEVO FALDA"}
WF03_CicloPrelFalda();
{endregion}	 

{region "WorkFlow 4 -  CICLO DEPOSITO FALDA"}		  
WF04_CicloDepFalda();
{endregion}	 

{region "WorkFlow 5 -  CICLO PRELIEVO LASTRA DA PP"}
WF05_CicloPrelLastraDaPP();
{endregion}	 

{region "WorkFlow 6 -  CICLO DEPOSITO LASTRA DA PP"}
WF06_CicloDepLastraDaPP();
{endregion}	 

{region "WorkFlow 7 -  CICLO PRELIEVO LASTRA DA WA"}
WF07_CicloPrelLastraDaWA();
{endregion}	 

{region "WorkFlow 8 -  CICLO DEPOSITO SU PAREGGIATORE "}
WF08_CicloDepLastraSuPareggiatore();
{endregion}	 
	 
{region "WorkFlow 9 -  CICLO DEPOSITO LASTRA DA WA"}
WF09_CicloDepLastraDaWA();
{endregion}	 

{region "WorkFlow 10 -  CICLO PRELIEVO LASTRA DA WA DEPAL"}
WF10_CicloPelLastra_Depal();
{endregion}	 	 

{region "WorkFlow 11 -  CICLO DEPOSITO FALDA DEPAL "}
WF11_CicloDepFalde_Depal();
{endregion}	 

{region "WorkFlow 12 -  CICLO DEPOSITO LASTRA DEPAL "}
WF12_CicloDepLastra_Depal();
{endregion}	 


(* Setto la memoria di richiesta stop in fase *)
WaitPositionRequest := (WaitPositionRequest OR ExternalWaitPositionRequest OR CmdExe.PhaseStopRequest > 0);

{region "GESTIONE INTERPOLAZIONE"}
(* Richiamo la FB di interpolazione degli assi *)
FROM_HMI_PAL.HMI_AbilitaInterpolazioneAssi := TRUE;
IF FROM_HMI_PAL.HMI_AbilitaInterpolazioneAssi THEN
	(* Se gli assi stanno accelerando o decelerando NON ESEGUO l'interpolazione *)
	IF (ProgrammaToModule_X.InterpolaAsse = INTERPOLAZIONE_ASSE AND (Modules^.AX_X.Ax^.AxRef^.Status.Accelerating OR Modules^.AX_X.Ax^.AxRef^.Status.Decelerating)) OR ProgrammaToModule_X.Stato <> DA_ESEGUIRE THEN
		ProgrammaToModule_X.InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
	END_IF
	IF (ProgrammaToModule_Y.InterpolaAsse = INTERPOLAZIONE_ASSE AND (Modules^.AX_Y.Ax^.AxRef^.Status.Accelerating OR Modules^.AX_Y.Ax^.AxRef^.Status.Decelerating)) OR ProgrammaToModule_Y.Stato <> DA_ESEGUIRE THEN
		ProgrammaToModule_Y.InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
	END_IF
	IF (ProgrammaToModule_Z.InterpolaAsse = INTERPOLAZIONE_ASSE AND (Modules^.AX_Z.Ax^.AxRef^.Status.Accelerating OR Modules^.AX_Z.Ax^.AxRef^.Status.Decelerating)) OR ProgrammaToModule_Z.Stato <> DA_ESEGUIRE THEN
		ProgrammaToModule_Z.InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
	END_IF
	IF (ProgrammaToModule_J.InterpolaAsse = INTERPOLAZIONE_ASSE AND (Modules^.AX_J.Ax^.AxRef^.Status.Accelerating OR Modules^.AX_J.Ax^.AxRef^.Status.Decelerating)) OR ProgrammaToModule_J.Stato <> DA_ESEGUIRE THEN
		ProgrammaToModule_J.InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
	END_IF
	
	Interpolazione_Assi(InterpolaAssi 	:=  ADR(STARTInterpolazioneASSI^), 			(* Abilitazione dell'interpolazione degli assi *)
						RitardoEsecuzione := RitardoEsecuzioneInterpolazione,
						TempoCompensazioneDec := TempoCompensazioneDecelerazione,
						TempCompensazioneAcc := TempoCompensazioneAccelerazione,
						AssiInterpolati := ADR(AssiInterpolati),					(* Variabile che indica se gli assi sono stati interpolati *)
						DeltaMinimoInterpolazione_X := 2,
						DeltaMinimoInterpolazione_Y := 2,
						DeltaMinimoInterpolazione_Z := 2,
						DeltaMinimoInterpolazione_J := 1,
						(* Abilitazione degli assi interpolati *)
						Interpola_X 	:= ADR(ProgrammaToModule_X.InterpolaAsse),		(* Se TRUE abilita l'interpolazione dell'asse X *)
						Interpola_Y 	:= ADR(ProgrammaToModule_Y.InterpolaAsse),		(* Se TRUE abilita l'interpolazione dell'asse Y *)
						Interpola_Z 	:= ADR(ProgrammaToModule_Z.InterpolaAsse),		(* Se TRUE abilita l'interpolazione dell'asse Z *)
						Interpola_J 	:= ADR(ProgrammaToModule_J.InterpolaAsse),		(* Se TRUE abilita l'interpolazione dell'asse J *)
						(* Quota di inizio Interpolazione *)
						PuntoIniziale_X := Modules^.AX_X.Ax^.AxRef^.NcToPlc.ActPos,	(* Punto di Partenza asse *)
						PuntoIniziale_Y := Modules^.AX_Y.Ax^.AxRef^.NcToPlc.ActPos,	(* Punto di Partenza asse *)
						PuntoIniziale_Z := Modules^.AX_Z.Ax^.AxRef^.NcToPlc.ActPos,	(* Punto di Partenza asse *)
						PuntoIniziale_J := Modules^.AX_J.Ax^.AxRef^.NcToPlc.ActPos,	(* Punto di Partenza asse *)
						(* Quota di destinazione *)
						PuntoFinale_X 	:= ProgrammaToModule_X.Quota_Destinazione,	(* Punto di Arrivo asse *)
						PuntoFinale_Y 	:= ProgrammaToModule_Y.Quota_Destinazione,	(* Punto di Arrivo asse *)
						PuntoFinale_Z 	:= ProgrammaToModule_Z.Quota_Destinazione,	(* Punto di Arrivo asse *)
						PuntoFinale_J 	:= ProgrammaToModule_J.Quota_Destinazione,	(* Punto di Arrivo asse *)
						(* Dinamica Asse X *)	
						Vel_MAX_X		:= ProgrammaToModule_X.Velocita,			(* Velocità MASSIMA dell'asse X *)
						Acc_MAX_X		:= ProgrammaToModule_X.Accelerazione,		(* Accelerazione MASSIMA Asse X *)
						Dec_MAX_X		:= ProgrammaToModule_X.Decelerazione,		(* Decelerazione MASSIMA Asse X *)
						Jerk_MAX_X		:= ProgrammaToModule_X.Jerk,				(* Jerk MASSIMO Asse X *)
						(* Dinamica Massima Y *)
						Vel_MAX_Y		:= ProgrammaToModule_Y.Velocita,			(* Velocità MASSIMA dell'asse Y *)
						Acc_MAX_Y		:= ProgrammaToModule_Y.Accelerazione,		(* Accelerazione MASSIMA Asse Y *)
						Dec_MAX_Y		:= ProgrammaToModule_Y.Decelerazione,		(* Decelerazione MASSIMA Asse Y *)
						Jerk_MAX_Y		:= ProgrammaToModule_Y.Jerk,				(* Jerk MASSIMO Asse Y *)
						(* Dinamica Massima Z *)
						Vel_MAX_Z		:= ProgrammaToModule_Z.Velocita,			(* Velocità MASSIMA dell'asse Z *)
						Acc_MAX_Z		:= ProgrammaToModule_Z.Accelerazione,		(* Accelerazione MASSIMA Asse Z *)
						Dec_MAX_Z		:= ProgrammaToModule_Z.Decelerazione,		(* Decelerazione MASSIMA Asse Z *)
						Jerk_MAX_Z		:= ProgrammaToModule_Z.Jerk,				(* Jerk MASSIMO Asse Z *)
						(* Dinamica Massima Asse J *)
						Vel_MAX_J		:= ProgrammaToModule_J.Velocita,			(* Velocità MASSIMA dell'asse J *)
						Acc_MAX_J		:= ProgrammaToModule_J.Accelerazione,		(* Accelerazione MASSIMA Asse J *)
						Dec_MAX_J		:= ProgrammaToModule_J.Decelerazione,		(* Decelerazione MASSIMA Asse J *)
						Jerk_MAX_J		:= ProgrammaToModule_J.Jerk,				(* Jerk MASSIMO Asse J *)
						(* Accelerazione iniziale degli assi *)
						Acc_Iniziale_X  := ABS(Modules^.AX_X.Ax^.AxRef^.NcToPlc.SetAcc), 
						Acc_Iniziale_Y  := ABS(Modules^.AX_Y.Ax^.AxRef^.NcToPlc.SetAcc), 
						Acc_Iniziale_Z  := ABS(Modules^.AX_Z.Ax^.AxRef^.NcToPlc.SetAcc), 
						Acc_Iniziale_J  := ABS(Modules^.AX_J.Ax^.AxRef^.NcToPlc.SetAcc), 
						(* Velocità iniziale degli assi *)
						Vel_Iniziale_X	:= ABS(Modules^.AX_X.Ax^.AxRef^.NcToPlc.SetVelo),
						Vel_Iniziale_Y	:= ABS(Modules^.AX_Y.Ax^.AxRef^.NcToPlc.SetVelo),
						Vel_Iniziale_Z	:= ABS(Modules^.AX_Z.Ax^.AxRef^.NcToPlc.SetVelo),
						Vel_Iniziale_J	:= ABS(Modules^.AX_J.Ax^.AxRef^.NcToPlc.SetVelo),
						(* Set della velocità di percorrenza e del tempo di accelerazione/decelerazione *)
						Vel_Percorso	:= MAX(1000,FROM_HMI_PAL.HMI_VelocitaPercorso),		(* Velocità di percorenza della traiettoria interpolata *)
						TAcc			:= MIN(10,FROM_HMI_PAL.HMI_TempoAccDec));		      	    (* Tempo di accelerazione *)
						
						IF AssiInterpolati THEN
							IF ProgrammaToModule_X.InterpolaAsse = INTERPOLAZIONE_ASSE THEN
								ProgrammaToModule_X.Velocita 		:= Interpolazione_Assi.Vel_X;		
								ProgrammaToModule_X.Accelerazione 	:= MAX(10,Interpolazione_Assi.Acc_OUT_X);	
								ProgrammaToModule_X.Decelerazione 	:= MAX(10,Interpolazione_Assi.Dec_OUT_X);
								ProgrammaToModule_X.Jerk 			:= ProgrammaToModule_X.Jerk;//5000;//Interpolazione_Assi.Jerk_OUT_X;
							ELSE
								ProgrammaToModule_X.Jerk			:= ProgrammaToModule_X.Jerk; 				
							END_IF
		
							IF ProgrammaToModule_Y.InterpolaAsse = INTERPOLAZIONE_ASSE THEN //
								ProgrammaToModule_Y.Velocita 		:= Interpolazione_Assi.Vel_Y;	
								ProgrammaToModule_Y.Accelerazione 	:= MAX(10,Interpolazione_Assi.Acc_OUT_Y);
								ProgrammaToModule_Y.Decelerazione 	:= MAX(10,Interpolazione_Assi.Dec_OUT_Y);	
								ProgrammaToModule_Y.Jerk 			:= ProgrammaToModule_Y.Jerk;//5000;//Interpolazione_Assi.Jerk_OUT_Y;
							ELSE
								ProgrammaToModule_Y.Jerk			:= ProgrammaToModule_Y.Jerk;
							END_IF	
								
							IF ProgrammaToModule_Z.InterpolaAsse = INTERPOLAZIONE_ASSE THEN // 
								ProgrammaToModule_Z.Velocita 		:= Interpolazione_Assi.Vel_Z;		
								ProgrammaToModule_Z.Accelerazione 	:= MAX(10,Interpolazione_Assi.Acc_OUT_Z);		
								ProgrammaToModule_Z.Decelerazione 	:= MAX(10,Interpolazione_Assi.Dec_OUT_Z);		
								ProgrammaToModule_Z.Jerk 			:= ProgrammaToModule_J.Jerk;//5000;//Interpolazione_Assi.Jerk_OUT_Z;	
							ELSE
								ProgrammaToModule_Z.Jerk			:= ProgrammaToModule_J.Jerk;	
							END_IF
							 
							IF ProgrammaToModule_J.InterpolaAsse  = INTERPOLAZIONE_ASSE	 THEN 
								ProgrammaToModule_J.Velocita 		:= Interpolazione_Assi.Vel_J;
								ProgrammaToModule_J.Accelerazione 	:= MAX(1,Interpolazione_Assi.Acc_OUT_J);
								ProgrammaToModule_J.Decelerazione 	:= MAX(1,Interpolazione_Assi.Dec_OUT_J);
								ProgrammaToModule_J.Jerk			:= ProgrammaToModule_J.Jerk;//5000;//Interpolazione_Assi.Jerk_OUT_J;
							ELSE
								ProgrammaToModule_J.Jerk			:= ProgrammaToModule_J.Jerk;
							END_IF
						END_IF
			
END_IF

//ProgrammaToModule_X.Jerk			:= 1000000000000;
//ProgrammaToModule_Y.Jerk			:= 1000000000000;
//PRogrammaToModule_Z.Jerk			:= 1000000000000;
//ProgrammaToModule_J.Jerk			:= 1000000000000;
//ProgrammaToModule_K.Jerk			:= 1000000000000;
(* Sbianco i flag di richiesta interpolazione *)
IF AssiInterpolati THEN
	FOR IndiceForSb := 0 TO 200 DO
		Programma_X[IndiceForSb].InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
		Programma_Y[IndiceForSb].InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
		Programma_Z[IndiceForSb].InterpolaAsse := NO_INTERPOLAZIONE_ASSE;
		Programma_J[IndiceForSb].InterpolaAsse := NO_INTERPOLAZIONE_ASSE;	
	END_FOR
END_IF
{endregion}	

(* ******************************************************************************************************** *)
(* Handshakes *)
(* ******************************************************************************************************** *)
					
(* ******************************************************************************************************** *)
(* State Input/Output *)
(* ******************************************************************************************************** *)
(* Fill Input/Output bit with sensor, electrovalve, etc. status *)

(* ******************************************************************************************************** *)
(* Errors *)
(* ******************************************************************************************************** *)

(* ******************************************************************************************************** *)
(* Input *)
(* ******************************************************************************************************** *)
(*Azzeramento comando di step HMI*)
HMI_CommandSTEP := CommandSTEP;

(* ******************************************************************************************************** *)
(* Error Check - Clear All Output!!! *)
(* ******************************************************************************************************** *)
IF TFPalletizerIsModuleError(Modules) THEN
	IF CmdExe.Code <> CmdNOP THEN
		IF CmdExe.Code <> CmdSTOP AND
			CmdExe.Code <> CmdPOWER AND
			CmdExe.Code <> CmdRESET AND
			CmdExe.Code <> CmdINIT AND
			CmdExe.Code <> CmdMAN AND
			CmdExe.Code <> CmdCICLORIPOSO THEN
			TFCommandClear(ADR(CmdNext));
			TFCommandExeClear(ADR(CmdExe));
			(* Clear All Output Here *)

		END_IF
	END_IF
	//OUT.HomeDone := FALSE;
END_IF;

(* ******************************************************************************************************** *)
(* Error Check - All Modules *)
(* ******************************************************************************************************** *)

(* ******************************************************************************************************** *)
(* Alarm *)
(* ******************************************************************************************************** *)
IF NOT IN.SensorAir AND NOT AirAlarmTrig THEN
	AirAlarmTrig := TRUE;
	TFParametersArrayClear(ADR (ParametersArray));
	TFCommandSend(CmdSTOP,ParametersArray,Cmd);
	TFError(ErrMACHINEPALLETIZER_AIR,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF

IF NOT IN.Sensor24Volt AND NOT Volt24Trig THEN
	Volt24Trig := TRUE;
	TFParametersArrayClear(ADR (ParametersArray));
	TFCommandSend(CmdSTOP,ParametersArray,Cmd);
	TFError(ErrMACHINEPALLETIZER_MAIN24V,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF

(* Controllo dei sensori di sicurezza delle cinghie *)
IF NOT IN.Y_BeltSafety AND NOT BeltSafetyTRIG AND IN.Mode.Auto THEN
	BeltSafetyTRIG := TRUE;
	TFParametersArrayClear(ADR(ParametersArray));
	TFCommandSend(CmdSTOP,ParametersArray,Cmd);
	TFError(ErrYBELTSAFETY,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF

IF NOT IN.Z_BeltSafety AND NOT BeltSafetyTRIG AND IN.Mode.Auto THEN
	BeltSafetyTRIG := TRUE;
	TFParametersArrayClear(ADR(ParametersArray));
	TFCommandSend(CmdSTOP,ParametersArray,Cmd);
	TFError(ErrZBELTSAFETY,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF

(* Controllo comunicazione con Trasporti *)

TFTimerSet(ADR(TimerComTrasporti),2000,IN.WD_Trasporti);
IF TFTimerDone(ADR(TimerComTrasporti)) and AbilitaErroreComunicazioneTrasporti THEN
	TFError(ErrCOMUNICAZTRASPORTI,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF


(* ******************************************************************************************************** *)
(* Diagnostic State *)
(* ******************************************************************************************************** *)

(* ******************************************************************************************************** *)
(* Machine Horn/Error/Warning/Run Outputs *)
(* ******************************************************************************************************** *)
(* Warning/Error Lamp + Error Horn *)
w := 0;
e := 0;
(* Add Others Modules *)
//IF TFIsModuleWarning(Modules^.Robot.Warning) THEN w := w + 1; END_IF
//IF TFIsModuleError(Modules^.Robot.Error) THEN e := e + 1; END_IF

(* Stop Request in case of one or more Modules Error *)
IF e <> 0 THEN
	CmdExe.PhaseStopRequest := 1;
END_IF

OUT.Warning := MachinePalletizer_TF.CmdExe.Code = CmdDO AND 
				ActualPickingListFromHMI[1].State = e_StatoWorkOrder.TERMINATO AND 
				ActualPickingListFromHMI[2].State = e_StatoWorkOrder.TERMINATO AND 
				ActualPickingListFromHMI[3].State = e_StatoWorkOrder.TERMINATO AND 
				MachinePalletizer_TF.InWaitPosition;
				
OUT.Error := Modules^.AX_X.Error.Code > 0 OR
			 Modules^.AX_Y.Error.Code > 0 OR
			 Modules^.AX_Z.Error.Code > 0 OR
			 Modules^.AX_J.Error.Code > 0 OR
			 Modules^.Pinza.Error.Code > 0 OR
			 Error.Code > 0 OR 
			 LGVError > 0 OR
			 LayerStackEmpty > 0;

(* Controllo tastatori di sicurezza pinza, attivo il controllo SEMPRE quando macchina in automatico!!!! *)
IF MachinePalletizer_TF.IN.Mode.Auto THEN
	TouchErrorEnable := TRUE;
END_IF
IF TouchErrorEnable AND 
(Modules^.AX_X.Error.Code  = ErrTOUCHEMERGENCY OR
 Modules^.AX_Y.Error.Code = ErrTOUCHEMERGENCY OR
 Modules^.AX_Z.Error.Code = ErrTOUCHEMERGENCY OR
 Modules^.AX_J.Error.Code = ErrTOUCHEMERGENCY) THEN
 	TFError(ErrTOUCHEMERGENCY,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
	CmdExe.PhaseStopRequest := 1;
	CmdExe.RapidStopRequest := 1;
END_IF
			 
(* Errore generato all'interno del TFLGV*)
IF LGVError > 0 THEN
	TFError(LGVError,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF
(* Errore generato all'interno del TFLGV*)
IF GateAccessError > 0 THEN
	TFError(GateAccessError,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
END_IF

IF TFTimerDone(ADR(TimerLamp)) THEN
	TFTimerSet(ADR(TimerLamp),1000,TRUE);
	ClockLamp := NOT ClockLamp;
END_IF

IF (CmdExe.Code = CmdHOME OR CmdExe.Code = CmdDO) AND PalletStackEmpty = 0 AND LayerStackEmpty = 0 AND AllWABusy = 0 THEN
	OUT.Run := TRUE;
ELSIF (CmdExe.Code = CmdHOME OR CmdExe.Code = CmdDO) AND (PalletStackEmpty > 0 OR LayerStackEmpty > 0 OR AllWABusy > 0) THEN
	OUT.Run := ClockLamp;
ELSE
	OUT.Run := FALSE;	
END_IF	

IF IN.Mode.ResetRequest THEN
	HornAck := TRUE;
END_IF
IF TFTimerDone(ADR(Timer1000)) THEN
	TFTimerSet(ADR(Timer1000),1000,TRUE);
	HornClock := NOT HornClock;
	OUT.Horn := OUT.Error AND HornClock AND NOT HornAck;
	IF NOT OUT.Error THEN HornAck := FALSE; END_IF
END_IF

IF NOT MachinePalletizer_TF.IN.Mode.Auto AND AutoTrig THEN
	AutoToMan := TRUE;
END_IF
AutoTrig := MachinePalletizer_TF.IN.Mode.Auto;

IF GateAccesExecuted AND NOT GateAccesTrig THEN
	GateAcces := TRUE;
END_IF
GateAccesTrig := GateAccesExecuted;

IF IN.Mode.RapidStopRequest AND NOT ExecuteStopTilterTRIG THEN
	ExecuteStopTilter := TRUE;
END_IF
ExecuteStopTilterTRIG := IN.Mode.RapidStopRequest;

OUT.ClockSegnalazioni := HornClock;

// Clock Segnalazione Alternato
TFTimerCall(ADR(TimerONAlternato),Cfg.TimeBase);
TFTimerCall(ADR(TimerOFFAlternato),Cfg.TimeBase);

TFTimerSet(ADR(TimerONAlternato),300,NOT OUT.ClockSegnalazioniAlternato); //Tempo Sirena ON
TFTimerSet(ADR(TimerOFFAlternato),2000,OUT.ClockSegnalazioniAlternato); //Tempo Sirena OFF 

IF TFTimerDone(ADR(TimerOFFAlternato)) THEN
	OUT.ClockSegnalazioniAlternato := TRUE;
ELSIF TFTimerDone(ADR(TimerONAlternato)) THEN
	OUT.ClockSegnalazioniAlternato := FALSE;
END_IF

//AutoReset Sirena Segnalazioni
TFTimerCall(ADR(TimerSirenaOFF_Segnalazioni),Cfg.TimeBase);

TFTimerSet(ADR(TimerSirenaOFF_Segnalazioni),300000,NOT OUT.Warning); //Tempo dopo il quale la sirena smette di suonare

IF TFTimerDone(ADR(TimerSirenaOFF_Segnalazioni)) THEN
	OUT.ResetSirenaSegnalazioni := TRUE;
ELSIF AutoToMan THEN //se metto in manuale, resetto il timer
	OUT.ResetSirenaSegnalazioni := FALSE;	
END_IF


(* ******************************************************************************************************** *)
(* Common Outputs *)
(* ******************************************************************************************************** *)]]></ST>
    </Implementation>
    <Action Name="WF02_CicloDiRiposo" Id="{bc9c49a8-b0e9-4638-8487-3d24ed00159d}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 2 -  CICLO DI RIPOSO *)
(*-------------------------------------------------------------------------------------------*)
NumeroWF :=2;
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;
			OUT.StartTilter := TRUE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE

				IF QuotaFuoriIngombro_X_AVUOTO = 0 THEN
					QuotaFuoriIngombro_X_AVUOTO := WorkPickPoint^[1].X;
				END_IF
				IF QuotaFuoriIngombro_Y_AVUOTO = 0 THEN
					QuotaFuoriIngombro_Y_AVUOTO := WorkPickPoint^[1].Y;
				END_IF
				IF QuotaFuoriIngombro_Z_AVUOTO = 0 THEN
					QuotaFuoriIngombro_Z_AVUOTO := WorkPickPoint^[1].Z + 300;
				END_IF
				//IF QuotaFuoriIngombro_J_AVUOTO = 0 THEN
				//	QuotaFuoriIngombro_J_AVUOTO := 90;
				//END_IF
				

				TFProgramma_Ciclo_Riposo.X_Par := ParametriProgramma_X_CicloRiposo;
				TFProgramma_Ciclo_Riposo.Y_Par := ParametriProgramma_Y_CicloRiposo;
				TFProgramma_Ciclo_Riposo.Z_Par := ParametriProgramma_Z_CicloRiposo;
				TFProgramma_Ciclo_Riposo.J_Par := ParametriProgramma_J_CicloRiposo;
				//TFProgramma_Ciclo_Riposo.K_Par := ParametriProgramma_K_CicloRiposo;
				(******************************************************************************)					 
				TFProgramma_Ciclo_Riposo.Quota_Riposo_X := Mission^.XPick;
				TFProgramma_Ciclo_Riposo.Quota_Riposo_Y := Mission^.YPick;
				TFProgramma_Ciclo_Riposo.Quota_Riposo_Z := Mission^.ZPick;
				TFProgramma_Ciclo_Riposo.Quota_Riposo_J := Mission^.JPick;
				(******************************************************************************)
				TFProgramma_Ciclo_Riposo.Quota_Fuori_Ingombro_X := QuotaFuoriIngombro_X_AVUOTO; 
				TFProgramma_Ciclo_Riposo.Quota_Fuori_Ingombro_Y := QuotaFuoriIngombro_Y_AVUOTO;
 				TFProgramma_Ciclo_Riposo.Quota_Fuori_Ingombro_Z := QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Riposo.Quota_Fuori_Ingombro_J := QuotaFuoriIngombro_J_AVUOTO;
				
				TFProgramma_Ciclo_Riposo();
				(* Valuto se è abilitata l'interpolazione degli assi *)
				IF NOT AbilitaInterpolazioneAssi^ THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
				END_IF
			END_IF;
			
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

		
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
					TFCiclo_Di_Riposo.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Di_Riposo.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Di_Riposo.Ciclo						:= ADR(Ciclo_Di_Riposo);
			TFCiclo_Di_Riposo.Programma					:= ADR(TFProgramma_Ciclo_Riposo);
			TFCiclo_Di_Riposo.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Di_Riposo.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Di_Riposo.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Di_Riposo.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Di_Riposo.ModulePinza 		:= ADR(Modules^.Pinza);
			TFCiclo_Di_Riposo.StartInterpolazioneAssi 		:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Di_Riposo.AbilitazioneGlobalePassMode 		:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Di_Riposo.Abilita_Ciclo_Step		:= AbilitazioCiclo_TEST_STEP;
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Di_Riposo.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Di_Riposo.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Di_Riposo.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			TFCiclo_Di_Riposo();
			STEPCicloDONE := TFCiclo_Di_Riposo.STEPDone;
			
			IF TFCiclo_Di_Riposo.Ciclo^.Stato = TERMINATO THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF TFCiclo_Di_Riposo.Errore > 0 THEN
				TFError(TFCiclo_Di_Riposo.Errore,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);	 
			ELSIF TFCiclo_Di_Riposo.Ciclo^.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		
	END_CASE;
	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF03_CicloPrelFalda" Id="{b41d67c7-bad6-4721-b31b-51c2827b53fc}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 3 -  CICLO PRELIEVO FALDA *)
(*-------------------------------------------------------------------------------------------*)		
NumeroWF:=3;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;
			OUT.StartTilter := FALSE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE
				TFProgramma_Ciclo_Falda.X_Par := ParametriProgramma_X_CicloFalda;
				TFProgramma_Ciclo_Falda.Y_Par := ParametriProgramma_Y_CicloFalda;
				TFProgramma_Ciclo_Falda.Z_Par := ParametriProgramma_Z_CicloFalda;
				TFProgramma_Ciclo_Falda.J_Par := ParametriProgramma_J_CicloFalda;
				//TFProgramma_Ciclo_Falda.K_Par := ParametriProgramma_K_CicloFalda;
				
				(*X*)
				TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_X 	:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_X	 	:= Traiettoria^.EndPoint.X;	
				
				(*Y*)
				TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_Y 	:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_Y		:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombroColonne_Y;//(WorkSpace^.Y - IngombroSuperficialePinzaMAX_Global/2);
				
				(*Z*)
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Prelievo_Falda_Z 					:= Traiettoria^.PuntoDiApproccioStartPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_Z 								:= Traiettoria^.StartPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Deposito_Falda_SuPiazzola_Z 		:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_Z					:= Traiettoria^.EndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Deposito_Falda_SuCatastaPallet_Z	:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_Z				:= Traiettoria^.EndPoint.Z;
				TFProgramma_Ciclo_Falda.QUota_Fuori_Ingombro_Falda_Z 						:= QuotaFuoriIngombro_Z_ConFALDA;
				TFProgramma_Ciclo_Falda.Quota_Attesa_Caduta_Falda_Z							:= Modules^.AX_Z.Ax^.Status.ActPosition + OffsetCadutaFalda;//Quota_Attesa_Caduta_Falda_Z;
								
				(*J*)
				TFProgramma_Ciclo_Falda.Quota_Rotazione_Prelievo_Falda 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Falda.Quota_Rotazione_Deposito_Falda 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Falda();
				(* Valuto se è abilitata l'interpolazione degli assi *)
				IF NOT AbilitaInterpolazioneAssi^ THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
				END_IF
			END_IF;
			
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[3]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
					TFCiclo_Prelievo_Falda.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Prelievo_Falda.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Prelievo_Falda.Ciclo					:= ADR(Ciclo_Pelievo_Falda);
			TFCiclo_Prelievo_Falda.Programma				:= ADR(TFProgramma_Ciclo_Falda);
			TFCiclo_Prelievo_Falda.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Prelievo_Falda.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Prelievo_Falda.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Prelievo_Falda.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Prelievo_Falda.ModulePinza 		:= ADR(Modules^.Pinza);
			TFCiclo_Prelievo_Falda.StartInterpolazioneAssi 	:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Prelievo_Falda.AbilitazioneGlobalePassMode 		:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Prelievo_Falda.Abilita_Ciclo_Step		:= AbilitazioCiclo_TEST_STEP;
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Falda.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Falda.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Prelievo_Falda.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Prelievo_Falda();
			STEPCicloDONE := TFCiclo_Prelievo_Falda.STEPDone;
			
			IF Ciclo_Pelievo_Falda.Stato = TERMINATO THEN
				ProductOnGripper := KPRODUCTLOADED;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Pelievo_Falda.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[5]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
				
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[5]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		
	END_CASE;
	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF04_CicloDepFalda" Id="{f3d3ade2-f8cf-4b84-b241-fc3f9de59c20}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 4 -  CICLO DEPOSITO FALDA *)
(*-------------------------------------------------------------------------------------------*)	
NumeroWF:=4;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;
			OUT.StartTilter := FALSE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE
				TFProgramma_Ciclo_Falda.X_Par := ParametriProgramma_X_CicloFalda;
				TFProgramma_Ciclo_Falda.Y_Par := ParametriProgramma_Y_CicloFalda;
				TFProgramma_Ciclo_Falda.Z_Par := ParametriProgramma_Z_CicloFalda;
				TFProgramma_Ciclo_Falda.J_Par := ParametriProgramma_J_CicloFalda;
				
				(*X*)
				TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_X 	:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_X	 	:= Traiettoria^.EndPoint.X;	
				
				(*Y*)
				TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_Y 	:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_Y		:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombroColonne_Y;//(WorkSpace^.Y - IngombroSuperficialePinzaMAX_Global/2);

				(*Z*)
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Prelievo_Falda_Z 					:= Traiettoria^.PuntoDiApproccioStartPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_Z 								:= Traiettoria^.StartPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Deposito_Falda_SuPiazzola_Z 		:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_Z					:= Traiettoria^.EndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Deposito_Falda_SuCatastaPallet_Z	:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_Z				:= Traiettoria^.EndPoint.Z;
				TFProgramma_Ciclo_Falda.QUota_Fuori_Ingombro_Falda_Z 						:= QuotaFuoriIngombro_Z_ConFALDA;
				TFProgramma_Ciclo_Falda.Quota_Attesa_Caduta_Falda_Z							:= Modules^.AX_Z.Ax^.Status.ActPosition + OffsetCadutaFalda;//Quota_Attesa_Caduta_Falda_Z;
					
				(*J*)
				TFProgramma_Ciclo_Falda.Quota_Rotazione_Prelievo_Falda 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Falda.Quota_Rotazione_Deposito_Falda 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Falda();
				(* Valuto se è abilitata l'interpolazione degli assi *)
				IF NOT AbilitaInterpolazioneAssi^ THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
				END_IF
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
				TFCiclo_Deposito_Falda.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Deposito_Falda.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Deposito_Falda.Ciclo					:= ADR(Ciclo_Deposito_Falda);
			TFCiclo_Deposito_Falda.Programma				:= ADR(TFProgramma_Ciclo_Falda);
			TFCiclo_Deposito_Falda.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Deposito_Falda.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Deposito_Falda.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Deposito_Falda.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Deposito_Falda.ModulePinza 		:= ADR(Modules^.Pinza);
			TFCiclo_Deposito_Falda.StartInterpolazioneAssi 	:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Deposito_Falda.AbilitazioneGlobalePassMode 		:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Deposito_Falda.Abilita_Ciclo_Step		:= AbilitazioCiclo_TEST_STEP;
			(* Set della tipologia di deposito *)
			IF Workarea^[Mission^.PPlace].Typology = TYPOLOGY_STACK THEN 
				TFCiclo_Deposito_Falda.TipoDiDeposito		:= DEPOSITO_FALDA_SU_CATASTA;
			ELSIF Workarea^[Mission^.PPlace].Typology = TYPOLOGY_PALLET THEN
				TFCiclo_Deposito_Falda.TipoDiDeposito		:= DEPOSITO_FALDA_SU_PIAZZOLA;
			ELSE
				; //non dovrebbe mai accadere
			END_IF
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Falda.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Falda.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Deposito_Falda.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Deposito_Falda();
			STEPCicloDONE := TFCiclo_Deposito_Falda.STEPDone;
			
			IF Ciclo_Deposito_Falda.Stato = TERMINATO THEN
				OUT.StartTilter := TRUE;
				ProductOnGripper := KNOPRODUCT;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Deposito_Falda.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
		
	END_CASE;
	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF05_CicloPrelLastraDaPP" Id="{b73d9e92-ce4d-433e-a661-c69732b17d5c}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 5 -  CICLO PRELIEVO LASTRA DA PP *)
(*-------------------------------------------------------------------------------------------*)	
NumeroWF := 5;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;	
			OUT.StartTilter := TRUE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0  OR
				TFPalletizerIsModuleError(Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE

				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_X			:= Traiettoria^.PuntoDiApproccioStartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_X			:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Carico_X				:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Y         := Traiettoria^.PuntoDiApproccioStartPoint.Y;;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Y					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_AVUOTO;//DEVE ESSERE GUALE A QUELLE DEL CORRIDOIO
				
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 		:= MAX(Traiettoria^.PuntoDiApproccioStartPoint.Z,AxisPar_Z.MinPosition);
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= MAX(Traiettoria^.StartPoint.Z,AxisPar_Z.MinPosition);
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				IF HMI_AbilitaDepositoPaccoOrrizzontaleConTasteggio THEN
					TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= Traiettoria^.EndPoint.Z -100;
				ELSE
					TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= Traiettoria^.EndPoint.Z;
				END_IF
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z			:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z			:= QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Z					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_PostScarico							:= Z_Riposo;	
			
				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_StartTasteggio_Lastra		:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_J						:= QuotaFuoriIngombro_J_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Sfogliatura 				:= Traiettoria^.StartPoint.J + HMI_GradiSfogliaturaJ;

				TFProgramma_Ciclo_Lastra();
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFCiclo_Prelievo_Lastra.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Prelievo_Lastra.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Prelievo_Lastra.Ciclo					:= ADR(Ciclo_Prelievo_Lastra);
			TFCiclo_Prelievo_Lastra.Programma				:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Prelievo_Lastra.Modules 				:= Modules;
			TFCiclo_Prelievo_Lastra.StartInterpolazioneAssi := ADR(STARTInterpolazioneASSI^);
			TFCiclo_Prelievo_Lastra.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			TFCiclo_Prelievo_Lastra.AbilitazioneGlobalePassMode 			:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Prelievo_Lastra.Abilita_Ciclo_Step						:= AbilitazioCiclo_TEST_STEP;
			TFCiclo_Prelievo_Lastra.PrelievoPezzoOrizzontale				:= TRUE;
			TFCiclo_Prelievo_Lastra.NumeroTentativiPresa					:= HMI_NumeroTentativiPresa;
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Lastra.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Lastra.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Prelievo_Lastra.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Prelievo_Lastra();
			STEPCicloDONE := TFCiclo_Prelievo_Lastra.STEPDone;
			
			IF Ciclo_Prelievo_Lastra.Stato = TERMINATO THEN
				ProductOnGripper := KPRODUCTLOADED;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Prelievo_Lastra.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF06_CicloDepLastraDaPP" Id="{30fec531-b7d6-4a39-a8f9-a39de0bca3fc}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 6 -  CICLO DEPOSITO LASTRA PP *)
(*-------------------------------------------------------------------------------------------*)	
NumeroWF := 6;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0  OR
				TFPalletizerIsModuleError(Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE

				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_X			:= Traiettoria^.PuntoDiApproccioStartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_X			:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Carico_X				:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Y         := Traiettoria^.PuntoDiApproccioStartPoint.Y;;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Y					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_ConCARICO;//DEVE ESSERE GUALE A QUELLE DEL CORRIDOIO
				
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 		:= MAX(Traiettoria^.PuntoDiApproccioStartPoint.Z,AxisPar_Z.MinPosition);
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= MAX(Traiettoria^.StartPoint.Z,AxisPar_Z.MinPosition);
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= Traiettoria^.EndPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z			:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z			:= QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Z					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_PostScarico							:= Z_Riposo;	
			
				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_StartTasteggio_Lastra		:= Traiettoria^.PuntoDiApproccioStartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_J						:= QuotaFuoriIngombro_J_ConCARICO;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Sfogliatura 				:= Traiettoria^.StartPoint.J + HMI_GradiSfogliaturaJ;

				TFProgramma_Ciclo_Lastra();
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
				TFCiclo_Deposito_Lastra.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Deposito_Lastra.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Deposito_Lastra.Ciclo					:= ADR(Ciclo_Deposito_Lastra);
			TFCiclo_Deposito_Lastra.Programma				:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Deposito_Lastra.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Deposito_Lastra.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Deposito_Lastra.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Deposito_Lastra.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Deposito_Lastra.ModulePinza 			:= ADR(Modules^.Pinza);
			TFCiclo_Deposito_Lastra.StartInterpolazioneAssi := ADR(STARTInterpolazioneASSI^);
			TFCiclo_Deposito_Lastra.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			TFCiclo_Deposito_Lastra.AbilitazioneGlobalePassMode 			:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Deposito_Lastra.Abilita_Ciclo_Step						:= AbilitazioCiclo_TEST_STEP;
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Deposito_Lastra();
			STEPCicloDONE := TFCiclo_Deposito_Lastra.STEPDone;
			
			IF Ciclo_Deposito_Lastra.Stato = TERMINATO THEN
				ProductOnGripper := KNOPRODUCT;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Deposito_Lastra.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF07_CicloPrelLastraDaWA" Id="{d2ec37b6-0813-4314-836a-5ea6dee9d3f6}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 7 -  CICLO PRELIEVO LASTRA DA WA *)
(*-------------------------------------------------------------------------------------------*)	
NumeroWF := 7;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;	
			OUT.StartTilter := TRUE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0  OR
				TFPalletizerIsModuleError(Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE

				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_X			:= Traiettoria^.PuntoDiApproccioStartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_X			:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Carico_X				:= Traiettoria^.StartPoint.X;
				//*****************************************************************
				CoordenadaPosGiroPieza_X := WorkArea^[NuPosGuiroPiking].X ;
				TFProgramma_Ciclo_Lastra.Quota_PosGiroPiezaTraCavalleteX			:= CoordenadaPosGiroPieza_X ;
				//*****************************************************************
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Y         := Traiettoria^.PuntoDiApproccioStartPoint.Y;;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Y					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_PasilloCavallete0GradosY             := CoordenadaPasillo0_Y ;
				TFProgramma_Ciclo_Lastra.Quota_PasilloCavallete1800GradosY          := CoordenadaPasillo180_Y ;
				
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 		:= MAX(Traiettoria^.PuntoDiApproccioStartPoint.Z,AxisPar_Z.MinPosition+1);
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= MAX(Traiettoria^.StartPoint.Z,AxisPar_Z.MinPosition+1);
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= MAX(Traiettoria^.EndPoint.Z,AxisPar_Z.MinPosition+1);
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z			:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z			:= QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Z					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_PostScarico							:= Z_Riposo;	
			
				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_StartTasteggio_Lastra		:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_J						:= QuotaFuoriIngombro_J_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Sfogliatura 				:= Traiettoria^.StartPoint.J + HMI_GradiSfogliaturaJ;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_AttualeJ 				:= QuotaFuoriIngombro_J_AVUOTO;

				TFProgramma_Ciclo_Lastra();
				CommandSTEP := FALSE;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFCiclo_Prelievo_Lastra.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Prelievo_Lastra.InterrompiCiclo := FALSE;
			END_IF

			TFCiclo_Prelievo_Lastra.Ciclo									:= ADR(Ciclo_Prelievo_Lastra);
			TFCiclo_Prelievo_Lastra.Programma								:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Prelievo_Lastra.Modules	 								:= Modules;
			TFCiclo_Prelievo_Lastra.StartInterpolazioneAssi 				:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Prelievo_Lastra.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			TFCiclo_Prelievo_Lastra.AbilitazioneGlobalePassMode 			:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Prelievo_Lastra.Abilita_Ciclo_Step						:= AbilitazioCiclo_TEST_STEP;
			TFCiclo_Prelievo_Lastra.PrelievoPezzoOrizzontale				:= Mission^.JPick = 90;
			TFCiclo_Prelievo_Lastra.NumeroTentativiPresa					:= HMI_NumeroTentativiPresa;
			TFCiclo_Prelievo_Lastra.Mission									:= Mission;
			//TFCiclo_Prelievo_Lastra.Quota_Rotazione_StartTasteggio_Lastra   := Quota_Rotazione_StartTasteggio_Lastra ;
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Lastra.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Lastra.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Prelievo_Lastra.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Prelievo_Lastra();
			STEPCicloDONE := TFCiclo_Prelievo_Lastra.STEPDone;
			
			IF TFCiclo_Prelievo_Lastra.Ciclo^.Stato = TERMINATO THEN
				ProductOnGripper := KPRODUCTLOADED;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF TFCiclo_Prelievo_Lastra.Errore > 0 THEN
				TFError(TFCiclo_Prelievo_Lastra.Errore,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);	 
			ELSIF TFCiclo_Prelievo_Lastra.Ciclo^.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF08_CicloDepLastraSuPareggiatore" Id="{8d83cd10-698b-49a1-bf08-1664c0ce72a5}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 8 -  CICLO DEPOSITO LASTRA SU PAREGGIATORE *)
(*-------------------------------------------------------------------------------------------*)		
NumeroWF := 8;
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;
			OUT.StartTilter := TRUE;
			PaccoPresoXDataLogger := FALSE;
			IF NOT AttivaTimerContaPacchi1Minuto THEN
				AttivaTimerContaPacchi1Minuto := TRUE;
				AttivaTimerContaPacchi5Minuti := TRUE;
				Pacchi1Minuto := Pacchi1Minuto +1;
			ELSIF AttivaTimerContaPacchi1Minuto THEN
				AttivaTimerContaPacchi1Minuto := TRUE;
				Pacchi1Minuto := Pacchi1Minuto +1;
			END_IF	
			
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE
				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombroColonne_Y;//(WorkSpace^.Y - IngombroSuperficialePinzaMAX_Global/2);
				
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 			:= Traiettoria^.PuntoDiApproccioStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= Traiettoria^.StartPoint.Z;
				TFProgramma_Ciclo_Lastra.DisabilitaDepositoConTasteggio				:= (NOT AbilitaDepositoPaccoOrrizzonataleConTasteggio^ OR
																						SimulazioneSenzaPalletFalde);
				
				(* Se non ho abilitato il tasteggio in fase di deposito pacco orrizzontale e la missione non prevede deposito orrizzintale do la quota reale*)
				IF TFProgramma_Ciclo_Lastra.DisabilitaDepositoConTasteggio THEN
					TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
					TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z						:= Traiettoria^.EndPoint.Z;
				ELSE // Altrimenti faccio scendere di più l'asse Z in modo da far avvenire il tasteggio.....
					TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z + 10;
					TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z						:= Traiettoria^.EndPoint.Z - 100;
				END_IF
				
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z		:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z	:= QuotaFuoriIngombro_Z_AVUOTO;
				
				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra();
				IF TFProgramma_Ciclo_Lastra.Inizializzato THEN
					(* Valuto se è abilitata l'interpolazione degli assi *)
					IF NOT AbilitaInterpolazioneAssi^ THEN
						TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
					ELSE
						TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
					END_IF
				END_IF
				
				PaccoPresoXDataLogger := TRUE;
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro SENZA INTERPOLAZIONE ASSI *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

		
		(* Case 30 - Chiamata FB del ciclo di lavoro CON INTERPOLAZIONE ASSI *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) THEN
				TFCiclo_Deposito_Lastra.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Deposito_Lastra.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Deposito_Lastra.Ciclo					:= ADR(Ciclo_Deposito_Lastra);
			TFCiclo_Deposito_Lastra.Programma				:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Deposito_Lastra.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Deposito_Lastra.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Deposito_Lastra.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Deposito_Lastra.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Deposito_Lastra.ModulePinza 		:= ADR(Modules^.Pinza);
			TFCiclo_Deposito_Lastra.StartInterpolazioneAssi 				:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Deposito_Lastra.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			//TFCiclo_Deposito_Lastra.AbilitaDepositoPaccoOrrizzontaleConTasteggio	:= (AbilitaDepositoPaccoOrrizzonataleConTasteggio^ AND NOT SimulazioneSenzaPalletFalde);
			//TFCiclo_Deposito_Lastra.AbilitaAccostamentoAsseZ						:= AbilitaAccostamentoAsseZ^;
			TFCiclo_Deposito_Lastra.AbilitazioneGlobalePassMode 					:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Deposito_Lastra.Abilita_Ciclo_Step								:= AbilitazioCiclo_TEST_STEP;
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Deposito_Lastra();
			STEPCicloDONE := TFCiclo_Deposito_Lastra.STEPDone;
			
			IF Ciclo_Deposito_Lastra.Stato = TERMINATO THEN
				OUT.StartTilter := TRUE;
				ProductOnGripper := KNOPRODUCT;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Deposito_Lastra.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);	
					
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			ResetComandoRibaltinoEseguito := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF	 ]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF09_CicloDepLastraDaWA" Id="{f7133d13-13cc-4b52-87bb-c874bdd17301}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 9 -  CICLO DEPOSITO LASTRA PP *)
(*-------------------------------------------------------------------------------------------*)	
NumeroWF := 9;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0  OR
				TFPalletizerIsModuleError(Modules) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE

				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_X			:= Traiettoria^.PuntoDiApproccioStartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_X			:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Carico_X				:= Traiettoria^.EndPoint.X;
				
				//*************************
			   	CoordenadaPosGiroPieza_X 											:= WorkArea^[NuPosGuiroPiking].X ;
				TFProgramma_Ciclo_Lastra.Quota_PosGiroPiezaTraCavalleteX			:= CoordenadaPosGiroPieza_X ;
				//*****************************
				
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Y         := Traiettoria^.PuntoDiApproccioStartPoint.Y;;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Y					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_ConCARICO;//DEVE ESSERE GUALE A QUELLE DEL CORRIDOIO
				TFProgramma_Ciclo_Lastra.Quota_PasilloCavallete0GradosY             := CoordenadaPasillo0_Y ;
				TFProgramma_Ciclo_Lastra.Quota_PasilloCavallete1800GradosY          := CoordenadaPasillo180_Y ;
			
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 		:= MAX(Traiettoria^.PuntoDiApproccioStartPoint.Z,AxisPar_Z.MinPosition+1);
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= MAX(Traiettoria^.StartPoint.Z,AxisPar_Z.MinPosition+1);
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= MAX(Traiettoria^.EndPoint.Z,AxisPar_Z.MinPosition+1);
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z			:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z			:= QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Z					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_PostScarico							:= Z_Riposo;	
			
				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_StartTasteggio_Lastra		:= Traiettoria^.PuntoDiApproccioStartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_J						:= QuotaFuoriIngombro_J_ConCARICO;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Sfogliatura 				:= Traiettoria^.StartPoint.J + HMI_GradiSfogliaturaJ;
				TFProgramma_Ciclo_Lastra.Quota_Posicion_Giro_Pinza					:= WorkSpace^.Y / 2 +900;
				TFProgramma_Ciclo_Lastra();
				CommandSTEP := FALSE;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFCiclo_Deposito_Lastra.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Deposito_Lastra.InterrompiCiclo := FALSE;
			END_IF
			
			EseguitoAllinementoPezziDeposito := FALSE;//Azzeramento per dare la possibilità di allineare le lastre in fase di distacco aspirazione in manuale
			
			TFCiclo_Deposito_Lastra.Ciclo					:= ADR(Ciclo_Deposito_Lastra);
			TFCiclo_Deposito_Lastra.Programma				:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Deposito_Lastra.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Deposito_Lastra.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Deposito_Lastra.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Deposito_Lastra.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Deposito_Lastra.ModulePinza 			:= ADR(Modules^.Pinza);
			TFCiclo_Deposito_Lastra.StartInterpolazioneAssi := ADR(STARTInterpolazioneASSI^);
			TFCiclo_Deposito_Lastra.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			TFCiclo_Deposito_Lastra.AbilitazioneGlobalePassMode 			:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Deposito_Lastra.Abilita_Ciclo_Step						:= AbilitazioCiclo_TEST_STEP;
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Deposito_Lastra.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Deposito_Lastra();
			STEPCicloDONE := TFCiclo_Deposito_Lastra.STEPDone;
			
			IF TFCiclo_Deposito_Lastra.Ciclo^.Stato = TERMINATO THEN
				ProductOnGripper := KNOPRODUCT;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF TFCiclo_Deposito_Lastra.Errore > 0 THEN
				TFError(TFCiclo_Deposito_Lastra.Errore,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);	 
			ELSIF TFCiclo_Deposito_Lastra.Ciclo^.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF10_CicloPelLastra_Depal" Id="{9168d16d-10ac-4c5a-b75b-60b787d70133}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 10 -  CICLO PRELIEVO LASTRA DA WA DEPAL*)
(*-------------------------------------------------------------------------------------------*)	
NumeroWF := 10;	
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;	
			OUT.StartTilter := TRUE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE
				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_X			:= Traiettoria^.PuntoDiApproccioStartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_X			:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Carico_X				:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Y         := Traiettoria^.PuntoDiApproccioStartPoint.Y;;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Y					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_AVUOTO;//DEVE ESSERE GUALE A QUELLE DEL CORRIDOIO
				
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 		:= MAX(Traiettoria^.PuntoDiApproccioStartPoint.Z,AxisPar_Z.MinPosition);
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= MAX(Traiettoria^.StartPoint.Z,AxisPar_Z.MinPosition);
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;
				IF HMI_AbilitaDepositoPaccoOrrizzontaleConTasteggio THEN
					TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= Traiettoria^.EndPoint.Z -100;
				ELSE
					TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= Traiettoria^.EndPoint.Z;
				END_IF
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z			:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z			:= QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Z					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_PostScarico							:= Z_Riposo;	
			
				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_StartTasteggio_Lastra		:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_J						:= QuotaFuoriIngombro_J_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Sfogliatura 				:= Traiettoria^.StartPoint.J + HMI_GradiSfogliaturaJ;


				TFProgramma_Ciclo_Lastra();

				(* Valuto se è abilitata l'interpolazione degli assi *)
				IF NOT AbilitaInterpolazioneAssi^ THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
				END_IF
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFCiclo_Prelievo_Lastra_Depalettizzatore.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Prelievo_Lastra_Depalettizzatore.InterrompiCiclo := FALSE;
			END_IF
			//Quota asse J x sfogliatura


			TFCiclo_Prelievo_Lastra.Ciclo					:= ADR(Ciclo_Prelievo_Lastra);
			TFCiclo_Prelievo_Lastra.Programma				:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Prelievo_Lastra.Modules 				 := Modules;
			TFCiclo_Prelievo_Lastra.StartInterpolazioneAssi := ADR(STARTInterpolazioneASSI^);
			TFCiclo_Prelievo_Lastra.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			TFCiclo_Prelievo_Lastra.AbilitazioneGlobalePassMode 			:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Prelievo_Lastra.Abilita_Ciclo_Step						:= AbilitazioCiclo_TEST_STEP;
			TFCiclo_Prelievo_Lastra.PrelievoPezzoOrizzontale				:= TRUE;
			TFCiclo_Prelievo_Lastra.NumeroTentativiPresa					:= HMI_NumeroTentativiPresa;			
		
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Lastra_Depalettizzatore.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Prelievo_Lastra_Depalettizzatore.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Prelievo_Lastra_Depalettizzatore.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Prelievo_Lastra_Depalettizzatore();
			STEPCicloDONE := TFCiclo_Prelievo_Lastra_Depalettizzatore.STEPDone;
			
			IF TFCiclo_Prelievo_Lastra_Depalettizzatore.Ciclo^.Stato = TERMINATO THEN
				OUT.StartTilter := TRUE;
				ProductOnGripper := KPRODUCTLOADED;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF TFCiclo_Prelievo_Lastra_Depalettizzatore.Ciclo^.Stato = INTERROTTO OR TFCiclo_Prelievo_Lastra_Depalettizzatore.Errore <> 0 THEN	
				
				IF TFCiclo_Prelievo_Lastra_Depalettizzatore.Errore <> 0 THEN	 
					CmdExe.PhaseStopRequest := 1;
					CmdExe.RapidStopRequest := 1;
					WorkFlow[NumeroWF].Enable := FALSE;
					CommandSTEP := FALSE;
					CommandSTEPTRIG := FALSE;
					AssiInterpolati := FALSE;
					TFCiclo_Prelievo_Lastra_Depalettizzatore.Ciclo^.Stato := INTERROTTO;
					TFCiclo_Prelievo_Lastra_Depalettizzatore.InterrompiCiclo := TRUE;
					TFError(TFCiclo_Prelievo_Lastra_Depalettizzatore.Errore,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);	
				END_IF	
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
			
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF11_CicloDepFalde_Depal" Id="{489213be-aaf5-40a1-a2a2-bbb1da42fdbe}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 11 -  CICLO DEPOSITO FALDE DEPAL *)
(*-------------------------------------------------------------------------------------------*)		
NumeroWF := 11;
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;
			OUT.StartTilter := TRUE;
			PaccoPresoXDataLogger := FALSE;
			IF NOT AttivaTimerContaPacchi1Minuto THEN
				AttivaTimerContaPacchi1Minuto := TRUE;
				AttivaTimerContaPacchi5Minuti := TRUE;
				Pacchi1Minuto := Pacchi1Minuto +1;
			ELSIF AttivaTimerContaPacchi1Minuto THEN
				AttivaTimerContaPacchi1Minuto := TRUE;
				Pacchi1Minuto := Pacchi1Minuto +1;
			END_IF	
			
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
				(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE
				TFProgramma_Ciclo_Falda.X_Par := ParametriProgramma_X_CicloFalda;
				TFProgramma_Ciclo_Falda.Y_Par := ParametriProgramma_Y_CicloFalda;
				TFProgramma_Ciclo_Falda.Z_Par := ParametriProgramma_Z_CicloFalda;
				TFProgramma_Ciclo_Falda.J_Par := ParametriProgramma_J_CicloFalda;
				
				(*X*)
				//TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_X 					:= Traiettoria^.StartPoint.X;
				//TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_X 	:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_X	 	:= Traiettoria^.EndPointSecondario.X;	
				//TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_X	 	:= Traiettoria^.EndPointSecondario.X;	
				(*Y*)
				//TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_Y 	:= Traiettoria^.EndPointSecondario.Y;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_Y		:= Traiettoria^.EndPointSecondario.Y;
				TFProgramma_Ciclo_Falda.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_ConCARICO;

				(*Z*)
				//TFProgramma_Ciclo_Falda.Quota_StartLenta_Prelievo_Falda_Z 					:= Traiettoria^.PuntoDiApproccioStartPoint.Z;
				//TFProgramma_Ciclo_Falda.Quota_Prelievo_Falda_Z 								:= Traiettoria^.StartPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Deposito_Falda_SuPiazzola_Z 		:= Traiettoria^.PuntoDiApproccioSecondarioEndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuPiazzola_Z					:= Traiettoria^.EndPointSecondario.Z;
				TFProgramma_Ciclo_Falda.Quota_StartLenta_Deposito_Falda_SuCatastaPallet_Z	:= Traiettoria^.PuntoDiApproccioSecondarioEndPoint.Z;
				TFProgramma_Ciclo_Falda.Quota_Deposito_Falda_SuCatastaPallet_Z				:= Traiettoria^.EndPointSecondario.Z;
				TFProgramma_Ciclo_Falda.QUota_Fuori_Ingombro_Falda_Z 						:= QuotaFuoriIngombro_Z_ConPEZZO;
				//TFProgramma_Ciclo_Falda.Quota_Attesa_Caduta_Falda_Z							:= Modules^.AX_Z.Ax^.Status.ActPosition + OffsetCadutaFalda;//Quota_Attesa_Caduta_Falda_Z;
					
				(*J*)
				//TFProgramma_Ciclo_Falda.Quota_Rotazione_Prelievo_Falda 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Falda.Quota_Rotazione_Deposito_Falda 			:= 90;//Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Falda();
				(* Valuto se è abilitata l'interpolazione degli assi *)
				IF NOT AbilitaInterpolazioneAssi^ THEN
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
				ELSE
					TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
				END_IF
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

			
		(* Case 30 - Chiamata FB del ciclo di lavoro *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFCiclo_Deposito_Falda_Depalettizzatore.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Deposito_Falda_Depalettizzatore.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Deposito_Falda_Depalettizzatore.Ciclo					:= ADR(Ciclo_Deposito_Falda_Depal);
			TFCiclo_Deposito_Falda_Depalettizzatore.Programma				:= ADR(TFProgramma_Ciclo_Falda);
			TFCiclo_Deposito_Falda_Depalettizzatore.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Deposito_Falda_Depalettizzatore.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Deposito_Falda_Depalettizzatore.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Deposito_Falda_Depalettizzatore.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Deposito_Falda_Depalettizzatore.ModulePinza 			:= ADR(Modules^.Pinza);
			TFCiclo_Deposito_Falda_Depalettizzatore.StartInterpolazioneAssi 			:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Deposito_Falda_Depalettizzatore.AbilitazioneGlobalePassMode 		:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Deposito_Falda_Depalettizzatore.Abilita_Ciclo_Step		:= AbilitazioCiclo_TEST_STEP;
			(* Set della tipologia di deposito *)
		//	IF Workarea^[Mission^.PPlace].Typology = TYPOLOGY_STACK THEN 
			//	TFCiclo_Deposito_Falda_Depalettizzatore.TipoDiDeposito		:= DEPOSITO_FALDA_SU_CATASTA;
			//ELSIF Workarea^[Mission^.PPlace].Typology = TYPOLOGY_PALLET THEN
				TFCiclo_Deposito_Falda_Depalettizzatore.TipoDiDeposito		:= DEPOSITO_FALDA_SU_PIAZZOLA;
			//ELSE
				//; //non dovrebbe mai accadere
			//END_IF
			
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Falda_Depalettizzatore.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Falda_Depalettizzatore.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Deposito_Falda_Depalettizzatore.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Deposito_Falda_Depalettizzatore();
			STEPCicloDONE := TFCiclo_Deposito_Falda_Depalettizzatore.STEPDone;
			
			IF Ciclo_Deposito_Falda_Depal.Stato = TERMINATO THEN
				OUT.StartTilter := TRUE;
				ProductOnGripper := KNOPRODUCT;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Deposito_Falda_Depal.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);		
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),0,WorkflowCase_JMP);
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF	 ]]></ST>
      </Implementation>
    </Action>
    <Action Name="WF12_CicloDepLastra_Depal" Id="{30866c03-294d-414c-b464-e0c9c9ac8599}">
      <Implementation>
        <ST><![CDATA[(*-------------------------------------------------------------------------------------------*)
(* WorkFlow 12 -  CICLO DEPOSITO LASTRA DEPAL *)
(*-------------------------------------------------------------------------------------------*)		
NumeroWF := 12;
IF WorkFlow[NumeroWF].Enable THEN

	IF NOT TFCommandCaseIsEnable(ADR(CmdExe)) THEN RETURN; END_IF
	CASE WorkFlow[NumeroWF].WFCase OF

		(* Case 0 *)
		0:  WorkFlow[NumeroWF].State := StateWF_RUN;
			STEPCicloDONE := FALSE;
			OUT.StartTilter := TRUE;
			PaccoPresoXDataLogger := FALSE;
			IF NOT AttivaTimerContaPacchi1Minuto THEN
				AttivaTimerContaPacchi1Minuto := TRUE;
				AttivaTimerContaPacchi5Minuti := TRUE;
				Pacchi1Minuto := Pacchi1Minuto +1;
			ELSIF AttivaTimerContaPacchi1Minuto THEN
				AttivaTimerContaPacchi1Minuto := TRUE;
				Pacchi1Minuto := Pacchi1Minuto +1;
			END_IF	
			
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),1,WorkflowCase_INC);
	
		(* Case 1 - Chiamata del FB del ciclo di riposo per Valorizzarne i valori*)
		1:	IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSE
				TFProgramma_Ciclo_Lastra.X_Par := ParametriProgramma_X_CicloLastra;
				TFProgramma_Ciclo_Lastra.Y_Par := ParametriProgramma_Y_CicloLastra;
				TFProgramma_Ciclo_Lastra.Z_Par := ParametriProgramma_Z_CicloLastra;
				TFProgramma_Ciclo_Lastra.J_Par := ParametriProgramma_J_CicloLastra;
				
				(*X*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_X			:= Traiettoria^.PuntoDiApproccioStartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_X 					:= Traiettoria^.StartPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_X	 		:= Traiettoria^.PuntoDiApproccioEndPoint.X;	
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_X 					:= Traiettoria^.EndPoint.X;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_X			:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Carico_X				:= Traiettoria^.EndPoint.X;//STESSA QUOTA DI DEPOSITO X DEPAL UNIVERSAL
				
				(*Y*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Y         := Traiettoria^.PuntoDiApproccioStartPoint.Y;;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Y 					:= Traiettoria^.StartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Y					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Y			:= Traiettoria^.PuntoDiApproccioEndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Y 					:= Traiettoria^.EndPoint.Y;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_Y 					:= QuotaFuoriIngombro_Y_ConCARICO;//DEVE ESSERE GUALE A QUELLE DEL CORRIDOIO
				
				(*Z*)
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Prelievo_Lastra_Z 		:= Traiettoria^.PuntoDiApproccioStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Prelievo_Lastra_Z 					:= Traiettoria^.StartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_StartLenta_Deposito_Lastra_Z			:= Traiettoria^.PuntoDiApproccioEndPoint.Z;// + PickPlaceParameters^.ZPlaceApproach;//OffsetSicurezza.Z.Carico;
				TFProgramma_Ciclo_Lastra.Quota_Deposito_Lastra_Z					:= Traiettoria^.EndPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_ConCarico_Z			:= QuotaFuoriIngombro_Z_ConPEZZO;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_SenzaCarico_Z			:= QuotaFuoriIngombro_Z_AVUOTO;
				TFProgramma_Ciclo_Lastra.Quota_Distacco_Lastra_Z					:= Traiettoria^.PuntoDiPostPosizionamentoStartPoint.Z;
				TFProgramma_Ciclo_Lastra.Quota_PostScarico							:= Traiettoria^.EndPoint.Z + 30; //Z_Riposo;

				(*J*)
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Prelievo_Lastra 			:= Traiettoria^.StartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_Deposito_Lastra 			:= Traiettoria^.EndPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Rotazione_StartTasteggio_Lastra		:= Traiettoria^.PuntoDiApproccioStartPoint.J;
				TFProgramma_Ciclo_Lastra.Quota_Fuori_Ingombro_J						:= QuotaFuoriIngombro_J_ConCARICO;
				TFProgramma_Ciclo_Lastra();

				IF TFProgramma_Ciclo_Lastra.Inizializzato THEN
					(* Valuto se è abilitata l'interpolazione degli assi *)
					IF NOT AbilitaInterpolazioneAssi^ THEN
						TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),20,WorkflowCase_JMP);	// Case con FB SENZA interpolazione
					ELSE
						TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione
					END_IF
				END_IF
				
				PaccoPresoXDataLogger := FALSE;
			END_IF;
		(* Case 20 - Chiamata FB del ciclo di lavoro SENZA INTERPOLAZIONE ASSI *)	
		20:	
			TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),30,WorkflowCase_JMP);	// Case con FB CON interpolazione

		
		(* Case 30 - Chiamata FB del ciclo di lavoro CON INTERPOLAZIONE ASSI *)	
		30:	
			IF CmdExe.RapidStopRequest > 0 OR
				TFPalletizerIsModuleError(Modules) OR Error.Code <> 0 OR 
				(CmdExe.PhaseStopRequest > 0 AND Ciclo_Deposito_Lastra_Depal.Passo = 56 AND NOT OkDepositoDaLinea) THEN
				TFCiclo_Deposito_Lastra_Depalettizzatore.InterrompiCiclo := TRUE;
			ELSE
				TFCiclo_Deposito_Lastra_Depalettizzatore.InterrompiCiclo := FALSE;
			END_IF
			TFCiclo_Deposito_Lastra_Depalettizzatore.Ciclo					:= ADR(Ciclo_Deposito_Lastra_Depal);
			TFCiclo_Deposito_Lastra_Depalettizzatore.Programma				:= ADR(TFProgramma_Ciclo_Lastra);
			TFCiclo_Deposito_Lastra_Depalettizzatore.ModuleAX_X 				:= ADR(Modules^.AX_X);
			TFCiclo_Deposito_Lastra_Depalettizzatore.ModuleAX_Y 				:= ADR(Modules^.AX_Y);
			TFCiclo_Deposito_Lastra_Depalettizzatore.ModuleAX_Z 				:= ADR(Modules^.AX_Z);
			TFCiclo_Deposito_Lastra_Depalettizzatore.ModuleAX_J 				:= ADR(Modules^.AX_J);
			TFCiclo_Deposito_Lastra_Depalettizzatore.ModulePinza 		:= ADR(Modules^.Pinza);
			TFCiclo_Deposito_Lastra_Depalettizzatore.StartInterpolazioneAssi 				:= ADR(STARTInterpolazioneASSI^);
			TFCiclo_Deposito_Lastra_Depalettizzatore.AbilitazioneAnticipoDinamicoMovimenti 	:= AbilitaAnticipoDinamico^;
			TFCiclo_Deposito_Lastra_Depalettizzatore.AbilitazioneGlobalePassMode 					:= Traiettoria^.PassModeGlobalEnable;
			TFCiclo_Deposito_Lastra_Depalettizzatore.Abilita_Ciclo_Step								:= AbilitazioCiclo_TEST_STEP;
			//TFCiclo_Deposito_Lastra_Depalettizzatore.MaterialeDepositatoSuLinea	=> MaterialeDepositatoSuLinea;	
	
			IF CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra_Depalettizzatore.Command_Step	:= TRUE;
				CommandSTEPTRIG := TRUE;
			ELSIF NOT CommandSTEP AND NOT CommandSTEPTRIG THEN
				TFCiclo_Deposito_Lastra_Depalettizzatore.Command_Step	:= FALSE;
				CommandSTEPTRIG := FALSE;
				CommandSTEP := FALSE;
			ELSIF  STEPCicloDONE THEN
				TFCiclo_Deposito_Lastra_Depalettizzatore.Command_Step	:= FALSE;
				CommandSTEP := FALSE;
				CommandSTEPTRIG := FALSE;
			END_IF
			
			TFCiclo_Deposito_Lastra_Depalettizzatore();
			STEPCicloDONE := TFCiclo_Deposito_Lastra_Depalettizzatore.STEPDone;
			
			IF Ciclo_Deposito_Lastra_Depal.Stato = TERMINATO THEN
				OUT.StartTilter := TRUE;
				ProductOnGripper := KNOPRODUCT;
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF (Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO AND (CmdExe.RapidStopRequest > 0 OR CmdExe.PhaseStopRequest > 0) AND Ciclo_Deposito_Lastra_Depal.Passo = 56 AND NOT OkDepositoDaLinea) THEN
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),100,WorkflowCase_JMP);
			ELSIF Ciclo_Deposito_Lastra_Depal.Stato = INTERROTTO THEN	
				TFWorkFlowCase(ADR(WorkFlow[NumeroWF]),999,WorkflowCase_JMP);	
			END_IF

		(* Case 100 *)
		100:WorkFlow[NumeroWF].State := StateWF_END;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			ResetComandoRibaltinoEseguito := FALSE;
			AssiInterpolati := FALSE;

		(* Case 999 *)
		(* WorkFlow ERROR *)
		StateWF_ERROR:
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			CmdExe.PhaseStopRequest := 1;
			CmdExe.RapidStopRequest := 1;
			WorkFlow[NumeroWF].Enable := FALSE;
			CommandSTEP := FALSE;
			CommandSTEPTRIG := FALSE;
			AssiInterpolati := FALSE;
		
		ELSE						
			TFWorkFlowError(ADR(WorkFlow[NumeroWF]),ADR(WorkFlowErrorLog[NumeroWF]));
			TFError(ErrNOCMDCASE,ErrNULL,ADR(CmdExe),ADR(State),ADR(Error),ADR(ErrorLog));	
	END_CASE;
END_IF	  ]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="TFMachinePalletizer_TF">
      <LineId Id="112080" Count="19" />
      <LineId Id="115838" Count="0" />
      <LineId Id="115847" Count="0" />
      <LineId Id="115846" Count="0" />
      <LineId Id="115852" Count="0" />
      <LineId Id="115850" Count="1" />
      <LineId Id="115848" Count="0" />
      <LineId Id="116111" Count="4" />
      <LineId Id="116110" Count="0" />
      <LineId Id="116339" Count="0" />
      <LineId Id="116338" Count="0" />
      <LineId Id="116098" Count="0" />
      <LineId Id="116101" Count="0" />
      <LineId Id="116104" Count="1" />
      <LineId Id="116107" Count="0" />
      <LineId Id="116109" Count="0" />
      <LineId Id="116106" Count="0" />
      <LineId Id="116102" Count="1" />
      <LineId Id="116099" Count="1" />
      <LineId Id="116836" Count="1" />
      <LineId Id="116598" Count="1" />
      <LineId Id="117294" Count="1" />
      <LineId Id="116602" Count="9" />
      <LineId Id="116596" Count="0" />
      <LineId Id="116839" Count="0" />
      <LineId Id="117301" Count="0" />
      <LineId Id="117300" Count="0" />
      <LineId Id="117347" Count="0" />
      <LineId Id="117346" Count="0" />
      <LineId Id="117308" Count="0" />
      <LineId Id="117310" Count="1" />
      <LineId Id="117313" Count="0" />
      <LineId Id="117317" Count="1" />
      <LineId Id="117320" Count="0" />
      <LineId Id="117319" Count="0" />
      <LineId Id="117315" Count="0" />
      <LineId Id="117321" Count="0" />
      <LineId Id="117316" Count="0" />
      <LineId Id="117323" Count="0" />
      <LineId Id="117329" Count="2" />
      <LineId Id="117336" Count="0" />
      <LineId Id="117332" Count="1" />
      <LineId Id="117322" Count="0" />
      <LineId Id="117334" Count="0" />
      <LineId Id="117340" Count="5" />
      <LineId Id="117338" Count="1" />
      <LineId Id="117335" Count="0" />
      <LineId Id="117314" Count="0" />
      <LineId Id="117309" Count="0" />
      <LineId Id="117304" Count="0" />
      <LineId Id="117572" Count="1" />
      <LineId Id="117306" Count="0" />
      <LineId Id="117574" Count="0" />
      <LineId Id="117305" Count="0" />
      <LineId Id="117299" Count="0" />
      <LineId Id="116097" Count="0" />
      <LineId Id="116582" Count="0" />
      <LineId Id="116342" Count="0" />
      <LineId Id="115602" Count="0" />
      <LineId Id="117064" Count="0" />
      <LineId Id="115840" Count="1" />
      <LineId Id="117063" Count="0" />
      <LineId Id="115843" Count="2" />
      <LineId Id="115839" Count="0" />
      <LineId Id="115828" Count="5" />
      <LineId Id="115827" Count="0" />
      <LineId Id="115603" Count="0" />
      <LineId Id="117068" Count="2" />
      <LineId Id="115604" Count="0" />
      <LineId Id="115598" Count="0" />
      <LineId Id="115834" Count="0" />
      <LineId Id="115853" Count="5" />
      <LineId Id="115835" Count="0" />
      <LineId Id="115860" Count="5" />
      <LineId Id="115859" Count="0" />
      <LineId Id="116088" Count="0" />
      <LineId Id="115836" Count="0" />
      <LineId Id="116089" Count="0" />
      <LineId Id="116091" Count="2" />
      <LineId Id="116096" Count="0" />
      <LineId Id="116095" Count="0" />
      <LineId Id="115837" Count="0" />
      <LineId Id="115599" Count="0" />
      <LineId Id="112100" Count="947" />
      <LineId Id="115149" Count="3" />
      <LineId Id="113048" Count="106" />
      <LineId Id="113158" Count="0" />
      <LineId Id="114909" Count="0" />
      <LineId Id="114918" Count="2" />
      <LineId Id="114910" Count="0" />
      <LineId Id="114921" Count="0" />
      <LineId Id="113161" Count="15" />
      <LineId Id="115375" Count="0" />
      <LineId Id="113177" Count="0" />
      <LineId Id="113179" Count="17" />
      <LineId Id="113198" Count="31" />
      <LineId Id="113231" Count="69" />
      <LineId Id="115145" Count="1" />
      <LineId Id="115144" Count="0" />
      <LineId Id="113301" Count="2" />
      <LineId Id="113305" Count="1275" />
      <LineId Id="114901" Count="0" />
      <LineId Id="114904" Count="0" />
      <LineId Id="114903" Count="0" />
      <LineId Id="114906" Count="0" />
      <LineId Id="114908" Count="0" />
      <LineId Id="114581" Count="90" />
      <LineId Id="114676" Count="0" />
      <LineId Id="114678" Count="0" />
      <LineId Id="114680" Count="0" />
      <LineId Id="114677" Count="0" />
      <LineId Id="114672" Count="3" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF02_CicloDiRiposo">
      <LineId Id="2" Count="98" />
      <LineId Id="131" Count="6" />
      <LineId Id="105" Count="25" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF03_CicloPrelFalda">
      <LineId Id="2" Count="129" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF04_CicloDepFalda">
      <LineId Id="2" Count="137" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF05_CicloPrelLastraDaPP">
      <LineId Id="2" Count="25" />
      <LineId Id="140" Count="34" />
      <LineId Id="63" Count="19" />
      <LineId Id="87" Count="52" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF06_CicloDepLastraDaPP">
      <LineId Id="2" Count="130" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF07_CicloPrelLastraDaWA">
      <LineId Id="2" Count="32" />
      <LineId Id="199" Count="2" />
      <LineId Id="166" Count="0" />
      <LineId Id="36" Count="6" />
      <LineId Id="196" Count="1" />
      <LineId Id="43" Count="4" />
      <LineId Id="49" Count="0" />
      <LineId Id="53" Count="10" />
      <LineId Id="194" Count="0" />
      <LineId Id="64" Count="1" />
      <LineId Id="193" Count="0" />
      <LineId Id="66" Count="14" />
      <LineId Id="165" Count="0" />
      <LineId Id="152" Count="2" />
      <LineId Id="159" Count="5" />
      <LineId Id="94" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="167" Count="15" />
      <LineId Id="185" Count="7" />
      <LineId Id="116" Count="23" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF08_CicloDepLastraSuPareggiatore">
      <LineId Id="2" Count="153" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF09_CicloDepLastraDaWA">
      <LineId Id="133" Count="31" />
      <LineId Id="278" Count="0" />
      <LineId Id="280" Count="1" />
      <LineId Id="284" Count="0" />
      <LineId Id="287" Count="0" />
      <LineId Id="165" Count="8" />
      <LineId Id="276" Count="1" />
      <LineId Id="174" Count="17" />
      <LineId Id="272" Count="0" />
      <LineId Id="192" Count="14" />
      <LineId Id="273" Count="2" />
      <LineId Id="207" Count="27" />
      <LineId Id="264" Count="7" />
      <LineId Id="240" Count="23" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF10_CicloPelLastra_Depal">
      <LineId Id="2" Count="24" />
      <LineId Id="170" Count="34" />
      <LineId Id="58" Count="27" />
      <LineId Id="205" Count="7" />
      <LineId Id="99" Count="17" />
      <LineId Id="127" Count="42" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF11_CicloDepFalde_Depal">
      <LineId Id="2" Count="145" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TFMachinePalletizer_TF.WF12_CicloDepLastra_Depal">
      <LineId Id="2" Count="154" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>